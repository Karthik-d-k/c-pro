{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"c-pro This repo contains solutions for the exercises in the book --> C Programming Language 2nd Edition by Brian W. Kernighan and Dennis M. Ritchie Contributing Feel free to raise a PR or open an issue, if you find any bugs/improvements in the code. Exercises Navigate to Docs folder for the solutions.","title":"Home"},{"location":"#c-pro","text":"This repo contains solutions for the exercises in the book --> C Programming Language 2nd Edition by Brian W. Kernighan and Dennis M. Ritchie","title":"c-pro"},{"location":"#contributing","text":"Feel free to raise a PR or open an issue, if you find any bugs/improvements in the code.","title":"Contributing"},{"location":"#exercises","text":"Navigate to Docs folder for the solutions.","title":"Exercises"},{"location":"Chapter_01/EX1_01/","text":"Exercise 1-1. Run the hello, world program on your system. Experiment with leaving out parts of the program, to see what error messages you get. /* Exercise 1-1. Run the `hello, world` program on your system. Experiment with leaving out parts of the program, to see what error messages you get. */ #include <stdio.h> int main () { printf ( \"hello, world \\n \" ); return 0 ; }","title":"Example 1"},{"location":"Chapter_01/EX1_01/#exercise-1-1-run-the-hello-world-program-on-your-system-experiment-with-leaving-out-parts-of-the-program-to-see-what-error-messages-you-get","text":"/* Exercise 1-1. Run the `hello, world` program on your system. Experiment with leaving out parts of the program, to see what error messages you get. */ #include <stdio.h> int main () { printf ( \"hello, world \\n \" ); return 0 ; }","title":"Exercise 1-1. Run the hello, world program on your system. Experiment with leaving out parts of the program, to see what error messages you get."},{"location":"Chapter_01/EX1_02/","text":"Exercise 1-2. Experiment to find out what happens when prints's argument string contains \\c, where c is some character not in \\n, \\t, \\b, \\\". /* Exercise 1-2. Experiment to find out what happens when prints's argument string contains \\c, where c is some character not in \\n, \\t, \\b, \\\". */ #include <stdio.h> int main () { printf ( \" \\a \" ); /* \u2018\\a\u2019 is an ASCII BEL character it is a terminal feature it produces a \u201cbeep\u201d sound or a notification sound simultaneously displaying a terminal or command prompt(windows) */ return 0 ; }","title":"Example 2"},{"location":"Chapter_01/EX1_02/#exercise-1-2-experiment-to-find-out-what-happens-when-printss-argument-string-contains-c-where-c-is-some-character-not-in-n-t-b","text":"/* Exercise 1-2. Experiment to find out what happens when prints's argument string contains \\c, where c is some character not in \\n, \\t, \\b, \\\". */ #include <stdio.h> int main () { printf ( \" \\a \" ); /* \u2018\\a\u2019 is an ASCII BEL character it is a terminal feature it produces a \u201cbeep\u201d sound or a notification sound simultaneously displaying a terminal or command prompt(windows) */ return 0 ; }","title":"Exercise 1-2. Experiment to find out what happens when prints's argument string contains \\c, where c is some character not in \\n, \\t, \\b, \\\"."},{"location":"Chapter_01/EX1_03/","text":"Exercise 1-3. Create the temperature conversion program (\u00b0F to \u00b0C) to print a heading above the table. /* Exercise 1-3. Create the temperature conversion program (\u00b0F to \u00b0C) to print a heading above the table.*/ #include <stdio.h> #define START 0 #define END 300 #define STEP 20 int main () { int i ; int temperature ; printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"Temperature Conversion from F to C \\n \" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"%3s \\t %6s \\n \" , \"F\" , \"C\" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); for ( i = START ; i <= END ; i = i + STEP ) { temperature = 5 * ( i - 32 ) / 9 ; printf ( \"%3d \\t %6d \\n \" , i , temperature ); } return 0 ; }","title":"Example 3"},{"location":"Chapter_01/EX1_03/#exercise-1-3-create-the-temperature-conversion-program-f-to-c-to-print-a-heading-above-the-table","text":"/* Exercise 1-3. Create the temperature conversion program (\u00b0F to \u00b0C) to print a heading above the table.*/ #include <stdio.h> #define START 0 #define END 300 #define STEP 20 int main () { int i ; int temperature ; printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"Temperature Conversion from F to C \\n \" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"%3s \\t %6s \\n \" , \"F\" , \"C\" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); for ( i = START ; i <= END ; i = i + STEP ) { temperature = 5 * ( i - 32 ) / 9 ; printf ( \"%3d \\t %6d \\n \" , i , temperature ); } return 0 ; }","title":"Exercise 1-3. Create the temperature conversion program (\u00b0F to \u00b0C) to print a heading above the table."},{"location":"Chapter_01/EX1_04/","text":"Exercise 1-4. Write a program to print the corresponding Celsius to Fahrenheit table. (\u00b0C to \u00b0F) /* Exercise 1-4. Write a program to print the corresponding Celsius to Fahrenheit table. (\u00b0C to \u00b0F) */ #include <stdio.h> #define START 0 #define END 300 #define STEP 20 int main () { int i ; int temperature ; printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"Temperature Conversion from C to F \\n \" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"%3s \\t %6s \\n \" , \"C\" , \"F\" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); for ( i = START ; i <= END ; i = i + STEP ) { temperature = (( i * 9 ) + 160 ) / 5 ; printf ( \"%3d \\t %6d \\n \" , i , temperature ); } return 0 ; }","title":"Example 4"},{"location":"Chapter_01/EX1_04/#exercise-1-4-write-a-program-to-print-the-corresponding-celsius-to-fahrenheit-table-c-to-f","text":"/* Exercise 1-4. Write a program to print the corresponding Celsius to Fahrenheit table. (\u00b0C to \u00b0F) */ #include <stdio.h> #define START 0 #define END 300 #define STEP 20 int main () { int i ; int temperature ; printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"Temperature Conversion from C to F \\n \" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"%3s \\t %6s \\n \" , \"C\" , \"F\" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); for ( i = START ; i <= END ; i = i + STEP ) { temperature = (( i * 9 ) + 160 ) / 5 ; printf ( \"%3d \\t %6d \\n \" , i , temperature ); } return 0 ; }","title":"Exercise 1-4. Write a program to print the corresponding Celsius to Fahrenheit table. (\u00b0C to \u00b0F)"},{"location":"Chapter_01/EX1_05/","text":"Exercise 1-5. Modify the temperature conversion program to print the table in reverse order, that is, from 300 degrees to 0. /* Exercise 1-5. Modify the temperature conversion program to print the table in reverse order, that is, from 300 degrees to 0. */ #include <stdio.h> #define START 0 #define END 300 #define STEP 20 int main () { int i ; int temperature ; printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"Temperature Conversion from C to F \\n \" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"%3s \\t %6s \\n \" , \"C\" , \"F\" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); for ( i = END ; i >= START ; i = i - STEP ) { temperature = (( i * 9 ) + 160 ) / 5 ; printf ( \"%3d \\t %6d \\n \" , i , temperature ); } return 0 ; }","title":"Example 5"},{"location":"Chapter_01/EX1_05/#exercise-1-5-modify-the-temperature-conversion-program-to-print-the-table-in-reverse-order-that-is-from-300-degrees-to-0","text":"/* Exercise 1-5. Modify the temperature conversion program to print the table in reverse order, that is, from 300 degrees to 0. */ #include <stdio.h> #define START 0 #define END 300 #define STEP 20 int main () { int i ; int temperature ; printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"Temperature Conversion from C to F \\n \" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"%3s \\t %6s \\n \" , \"C\" , \"F\" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); for ( i = END ; i >= START ; i = i - STEP ) { temperature = (( i * 9 ) + 160 ) / 5 ; printf ( \"%3d \\t %6d \\n \" , i , temperature ); } return 0 ; }","title":"Exercise 1-5. Modify the temperature conversion program to print the table in reverse order, that is, from 300 degrees to 0."},{"location":"Chapter_01/EX1_06/","text":"Exercsise 1-6. Verify that the expression getchar() != EOF is 0 or 1. /* Exercsise 1-6. Verify that the expression getchar() != EOF is 0 or 1. */ #include <stdio.h> int main () { int c ; c = ( getchar () != EOF ); printf ( \"%s\" , \"The value of the expression 'getchar() != EOF' is = \" ); printf ( \"%d\" , c ); return 0 ; }","title":"Example 6"},{"location":"Chapter_01/EX1_06/#exercsise-1-6-verify-that-the-expression-getchar-eof-is-0-or-1","text":"/* Exercsise 1-6. Verify that the expression getchar() != EOF is 0 or 1. */ #include <stdio.h> int main () { int c ; c = ( getchar () != EOF ); printf ( \"%s\" , \"The value of the expression 'getchar() != EOF' is = \" ); printf ( \"%d\" , c ); return 0 ; }","title":"Exercsise 1-6. Verify that the expression getchar() != EOF is 0 or 1."},{"location":"Chapter_01/EX1_07/","text":"Exercise 1-7. Write a program to print the value of EOF. /* Exercise 1-7. Write a program to print the value of EOF. */ #include <stdio.h> int main () { printf ( \"%s %d\" , \"The value of the 'EOF' is =\" , EOF ); return 0 ; }","title":"Example 7"},{"location":"Chapter_01/EX1_07/#exercise-1-7-write-a-program-to-print-the-value-of-eof","text":"/* Exercise 1-7. Write a program to print the value of EOF. */ #include <stdio.h> int main () { printf ( \"%s %d\" , \"The value of the 'EOF' is =\" , EOF ); return 0 ; }","title":"Exercise 1-7. Write a program to print the value of EOF."},{"location":"Chapter_01/EX1_08/","text":"Exercise 1-8. Write a program to count blanks, tabs, and newlines. /* Exercise 1-8. Write a program to count blanks, tabs, and newlines. */ #include <stdio.h> int main () { int n_blanks = 0 ; int n_tabs = 0 ; int n_lines = 0 ; int c ; while (( c = getchar ()) != EOF ) { if ( c == ' ' ) ++ n_blanks ; if ( c == '\\t' ) ++ n_tabs ; if ( c == '\\n' ) ++ n_lines ; } printf ( \"%s %d \\n \" , \"Number of blanks is =\" , n_blanks ); printf ( \"%s %d \\n \" , \"Number of tabs is =\" , n_tabs ); printf ( \"%s %d \\n \" , \"Number of newlines is =\" , n_lines ); return 0 ; }","title":"Example 8"},{"location":"Chapter_01/EX1_08/#exercise-1-8-write-a-program-to-count-blanks-tabs-and-newlines","text":"/* Exercise 1-8. Write a program to count blanks, tabs, and newlines. */ #include <stdio.h> int main () { int n_blanks = 0 ; int n_tabs = 0 ; int n_lines = 0 ; int c ; while (( c = getchar ()) != EOF ) { if ( c == ' ' ) ++ n_blanks ; if ( c == '\\t' ) ++ n_tabs ; if ( c == '\\n' ) ++ n_lines ; } printf ( \"%s %d \\n \" , \"Number of blanks is =\" , n_blanks ); printf ( \"%s %d \\n \" , \"Number of tabs is =\" , n_tabs ); printf ( \"%s %d \\n \" , \"Number of newlines is =\" , n_lines ); return 0 ; }","title":"Exercise 1-8. Write a program to count blanks, tabs, and newlines."},{"location":"Chapter_01/EX1_09/","text":"Exercise 1-9. Write a program to copy its input to its output, replacing each string of one or more blanks by a single blank. /* Exercise 1-9. Write a program to copy its input to its output, replacing each string of one or more blanks by a single blank. */ #include <stdio.h> int main () { int n_blanks = 0 ; int c ; printf ( \"%s \\n \" , \"Enter the input string \" ); while (( c = getchar ()) != EOF ) { if ( c != ' ' ) { if ( n_blanks > 1 ) putchar ( ' ' ); putchar ( c ); n_blanks = 0 ; } else { ++ n_blanks ; } } return 0 ; }","title":"Example 9"},{"location":"Chapter_01/EX1_09/#exercise-1-9-write-a-program-to-copy-its-input-to-its-output-replacing-each-string-of-one-or-more-blanks-by-a-single-blank","text":"/* Exercise 1-9. Write a program to copy its input to its output, replacing each string of one or more blanks by a single blank. */ #include <stdio.h> int main () { int n_blanks = 0 ; int c ; printf ( \"%s \\n \" , \"Enter the input string \" ); while (( c = getchar ()) != EOF ) { if ( c != ' ' ) { if ( n_blanks > 1 ) putchar ( ' ' ); putchar ( c ); n_blanks = 0 ; } else { ++ n_blanks ; } } return 0 ; }","title":"Exercise 1-9. Write a program to copy its input to its output, replacing each string of one or more blanks by a single blank."},{"location":"Chapter_01/EX1_10/","text":"Exercise 1-10. Write a program to copy its input to its output, replacing each tab by \\t, each backspace by \\b, and each backslash by \\. This makes tabs and backspaces visible in an unambiguous way. /* Exercise 1-10. Write a program to copy its input to its output, replacing each tab by \\t, each backspace by \\b, and each backslash by \\\\. This makes tabs and backspaces visible in an unambiguous way. */ #include <stdio.h> int main () { int c ; printf ( \"%s \\n \" , \"Enter the input string \" ); while (( c = getchar ()) != EOF ) { switch ( c ) { case '\\t' : putchar ( '\\\\' ); putchar ( 't' ); break ; case '\\b' : putchar ( '\\\\' ); putchar ( 'b' ); break ; case '\\\\' : putchar ( '\\\\' ); putchar ( '\\\\' ); break ; default : putchar ( c ); break ; } } return 0 ; }","title":"Example 10"},{"location":"Chapter_01/EX1_10/#exercise-1-10-write-a-program-to-copy-its-input-to-its-output-replacing-each-tab-by-t-each-backspace-by-b-and-each-backslash-by-this-makes-tabs-and-backspaces-visible-in-an-unambiguous-way","text":"/* Exercise 1-10. Write a program to copy its input to its output, replacing each tab by \\t, each backspace by \\b, and each backslash by \\\\. This makes tabs and backspaces visible in an unambiguous way. */ #include <stdio.h> int main () { int c ; printf ( \"%s \\n \" , \"Enter the input string \" ); while (( c = getchar ()) != EOF ) { switch ( c ) { case '\\t' : putchar ( '\\\\' ); putchar ( 't' ); break ; case '\\b' : putchar ( '\\\\' ); putchar ( 'b' ); break ; case '\\\\' : putchar ( '\\\\' ); putchar ( '\\\\' ); break ; default : putchar ( c ); break ; } } return 0 ; }","title":"Exercise 1-10. Write a program to copy its input to its output, replacing each tab by \\t, each backspace by \\b, and each backslash by \\. This makes tabs and backspaces visible in an unambiguous way."},{"location":"Chapter_01/EX1_11/","text":"Exercise 1-11. How would you test the word count program? What kinds of input are most likely to uncover bugs if there are any ? /* Exercise 1-11. How would you test the word count program? What kinds of input are most likely to uncover bugs if there are any ? */ #include <stdio.h> #define IN 1 /* inside a word */ #define OUT 0 /* outside a word */ /* count lines, words, and characters in input */ int main () { int c , nl , nw , nc , state ; state = OUT ; nl = nw = nc = 0 ; while (( c = getchar ()) != EOF ) { ++ nc ; if ( c == '\\n' ) ++ nl ; if (( c == ' ' ) || ( c == '\\n' ) || ( c == '\\t' )) /* (c = '\\t') is changed to (c == '\\t') to solve the bug. */ state = OUT ; else if ( state == OUT ) { state = IN ; ++ nw ; } } printf ( \"%d %d %d \\n \" , nl , nw , nc ); return 0 ; }","title":"Example 11"},{"location":"Chapter_01/EX1_11/#exercise-1-11-how-would-you-test-the-word-count-program-what-kinds-of-input-are-most-likely-to-uncover-bugs-if-there-are-any","text":"/* Exercise 1-11. How would you test the word count program? What kinds of input are most likely to uncover bugs if there are any ? */ #include <stdio.h> #define IN 1 /* inside a word */ #define OUT 0 /* outside a word */ /* count lines, words, and characters in input */ int main () { int c , nl , nw , nc , state ; state = OUT ; nl = nw = nc = 0 ; while (( c = getchar ()) != EOF ) { ++ nc ; if ( c == '\\n' ) ++ nl ; if (( c == ' ' ) || ( c == '\\n' ) || ( c == '\\t' )) /* (c = '\\t') is changed to (c == '\\t') to solve the bug. */ state = OUT ; else if ( state == OUT ) { state = IN ; ++ nw ; } } printf ( \"%d %d %d \\n \" , nl , nw , nc ); return 0 ; }","title":"Exercise 1-11. How would you test the word count program? What kinds of input are most likely to uncover bugs if there are any ?"},{"location":"Chapter_01/EX1_12/","text":"Exercise 1-12. Write a program that prints its input one word per line. /* Exercise 1-12. Write a program that prints its input one word per line. */ #include <stdio.h> int main () { int c , nw ; nw = 0 ; printf ( \"%s \\n \" , \"Enter the input : \" ); printf ( \"%s \\n \" , \"----------------------------\" ); while (( c = getchar ()) != EOF ) { if ( ! (( c == ' ' ) || ( c == '\\n' ) || ( c == '\\t' ))) putchar ( c ); else { putchar ( '\\n' ); /* use single quotes instead of double quotes to avoid -> warning : passing arg 1 of `putchar' makes integer from pointer without a cast. */ ++ nw ; /* just to count no. of words. */ } } printf ( \"%s \\n \" , \"----------------------------\" ); printf ( \"%s %d \\n \" , \"No of words present in the input : \" , nw ); return 0 ; }","title":"Example 12"},{"location":"Chapter_01/EX1_12/#exercise-1-12-write-a-program-that-prints-its-input-one-word-per-line","text":"/* Exercise 1-12. Write a program that prints its input one word per line. */ #include <stdio.h> int main () { int c , nw ; nw = 0 ; printf ( \"%s \\n \" , \"Enter the input : \" ); printf ( \"%s \\n \" , \"----------------------------\" ); while (( c = getchar ()) != EOF ) { if ( ! (( c == ' ' ) || ( c == '\\n' ) || ( c == '\\t' ))) putchar ( c ); else { putchar ( '\\n' ); /* use single quotes instead of double quotes to avoid -> warning : passing arg 1 of `putchar' makes integer from pointer without a cast. */ ++ nw ; /* just to count no. of words. */ } } printf ( \"%s \\n \" , \"----------------------------\" ); printf ( \"%s %d \\n \" , \"No of words present in the input : \" , nw ); return 0 ; }","title":"Exercise 1-12. Write a program that prints its input one word per line."},{"location":"Chapter_01/EX1_13/","text":"Exercise 1-13. Write a program to print a histogram of the lengths of words in its input. It is easy to draw the histogram with the bars horizontal; a vertical orientation is more challenging. /* Exercise 1-13. Write a program to print a histogram of the lengths of words in its input. It is easy to draw the histogram with the bars horizontal; a vertical orientation is more challenging. */ #include <stdio.h> int main () { int c , len ; len = 0 ; printf ( \"%s \\n \" , \"Enter the input : \" ); while (( c = getchar ()) != EOF ) { if ( ! (( c == ' ' ) || ( c == '\\n' ) || ( c == '\\t' ))) { ++ len ; printf ( \"*\" ); } else { len = 0 ; printf ( \" \\n \" ); } } return 0 ; }","title":"Example 13"},{"location":"Chapter_01/EX1_13/#exercise-1-13-write-a-program-to-print-a-histogram-of-the-lengths-of-words-in-its-input-it-is-easy-to-draw-the-histogram-with-the-bars-horizontal-a-vertical-orientation-is-more-challenging","text":"/* Exercise 1-13. Write a program to print a histogram of the lengths of words in its input. It is easy to draw the histogram with the bars horizontal; a vertical orientation is more challenging. */ #include <stdio.h> int main () { int c , len ; len = 0 ; printf ( \"%s \\n \" , \"Enter the input : \" ); while (( c = getchar ()) != EOF ) { if ( ! (( c == ' ' ) || ( c == '\\n' ) || ( c == '\\t' ))) { ++ len ; printf ( \"*\" ); } else { len = 0 ; printf ( \" \\n \" ); } } return 0 ; }","title":"Exercise 1-13. Write a program to print a histogram of the lengths of words in its input. It is easy to draw the histogram with the bars horizontal; a vertical orientation is more challenging."},{"location":"Chapter_01/EX1_14/","text":"Exercise 1-14. Write a program to print a histogram of the frequencies of different characters in its input. /* Exercise 1-14. Write a program to print a histogram of the frequencies of different characters in its input. */ #include <stdio.h> #define LIMIT 100 int main () { int c , i , j , k , u , l , found ; i = j = k = u = l = found = 0 ; char chars [ LIMIT ]; char unique [ LIMIT ]; int freqs [ LIMIT ]; printf ( \"%s \\n \" , \"Enter the input : \" ); while (( c = getchar ()) != EOF && i < LIMIT ) { chars [ i ++ ] = c ; for ( k = i -1 ; k >= 0 ; k -- ) { if ( chars [ i ] == chars [ k ]) { freqs [ k ] += 1 ; found = 1 ; } } if ( ! found ) { unique [ u ] = chars [ i ]; freqs [ u ] = 1 ; found = 0 ; u ++ ; } unique [ u ] = '\\0' ; } chars [ i ] = '\\0' ; printf ( \"%s %d \\n \" , \"unique characters in input : \" , u ); for ( l = 0 ; l < u ; l ++ ) printf ( \"%d -> %c \\n \" , freqs [ l ], unique [ l ]); return 0 ; } /* Code is not complete, yet to be completed */","title":"Example 14"},{"location":"Chapter_01/EX1_14/#exercise-1-14-write-a-program-to-print-a-histogram-of-the-frequencies-of-different-characters-in-its-input","text":"/* Exercise 1-14. Write a program to print a histogram of the frequencies of different characters in its input. */ #include <stdio.h> #define LIMIT 100 int main () { int c , i , j , k , u , l , found ; i = j = k = u = l = found = 0 ; char chars [ LIMIT ]; char unique [ LIMIT ]; int freqs [ LIMIT ]; printf ( \"%s \\n \" , \"Enter the input : \" ); while (( c = getchar ()) != EOF && i < LIMIT ) { chars [ i ++ ] = c ; for ( k = i -1 ; k >= 0 ; k -- ) { if ( chars [ i ] == chars [ k ]) { freqs [ k ] += 1 ; found = 1 ; } } if ( ! found ) { unique [ u ] = chars [ i ]; freqs [ u ] = 1 ; found = 0 ; u ++ ; } unique [ u ] = '\\0' ; } chars [ i ] = '\\0' ; printf ( \"%s %d \\n \" , \"unique characters in input : \" , u ); for ( l = 0 ; l < u ; l ++ ) printf ( \"%d -> %c \\n \" , freqs [ l ], unique [ l ]); return 0 ; } /* Code is not complete, yet to be completed */","title":"Exercise 1-14. Write a program to print a histogram of the frequencies of different characters in its input."},{"location":"Chapter_01/EX1_15/","text":"Exercise 1-15. Rewrite the temperature conversion program of Section 1.2 to use a function for conversion. /* Exercise 1-15. Rewrite the temperature conversion program of Section 1.2 to use a function for conversion.*/ #include <stdio.h> #define START 0 #define END 300 #define STEP 20 int fah_to_cel ( int fah ); int main () { int i ; int temperature ; printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"Temperature Conversion from F to C \\n \" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"%3s \\t %6s \\n \" , \"F\" , \"C\" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); for ( i = START ; i <= END ; i = i + STEP ) { temperature = fah_to_cel ( i ); printf ( \"%3d \\t %6d \\n \" , i , temperature ); } return 0 ; } int fah_to_cel ( int fah ) { return ( 5 * ( fah - 32 ) / 9 ); }","title":"Example 15"},{"location":"Chapter_01/EX1_15/#exercise-1-15-rewrite-the-temperature-conversion-program-of-section-12-to-use-a-function-for-conversion","text":"/* Exercise 1-15. Rewrite the temperature conversion program of Section 1.2 to use a function for conversion.*/ #include <stdio.h> #define START 0 #define END 300 #define STEP 20 int fah_to_cel ( int fah ); int main () { int i ; int temperature ; printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"Temperature Conversion from F to C \\n \" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); printf ( \"%3s \\t %6s \\n \" , \"F\" , \"C\" ); printf ( \"%s \\n \" , \"----------------------------------------\" ); for ( i = START ; i <= END ; i = i + STEP ) { temperature = fah_to_cel ( i ); printf ( \"%3d \\t %6d \\n \" , i , temperature ); } return 0 ; } int fah_to_cel ( int fah ) { return ( 5 * ( fah - 32 ) / 9 ); }","title":"Exercise 1-15. Rewrite the temperature conversion program of Section 1.2 to use a function for conversion."},{"location":"Chapter_01/EX1_16/","text":"Exercise 1-16. Revise the main routine of the longest-line program so it will correctly print the length of arbitrary long input lines, and as much as possible of the text. /* Exercise 1-16. Revise the main routine of the longest-line program so it will correctly print the length of arbitrary long input lines, and as much as possible of the text. */ #include <stdio.h> #define MAXlines 500 /* maximum input lines length */ #define MAXLENGTH 50 /* maximum possible text characters to print */ int lineslength ( char lines []); /* print the arbitrary input lines */ int main () { int len ; /* length of an input */ char lines [ MAXlines ]; /* input liness */ int l ; len = lineslength ( lines ); /*by passing lines -> we are calling by reference i.e, pointing to the 0th index address of an array by specifying array name */ printf ( \"%s %d \\n \" , \"length of an input\" , len ); for ( l = 0 ; l < MAXLENGTH ; ++ l ) putchar ( lines [ l ]); return 0 ; } /* getlines: read a lines into s, return length */ int lineslength ( char s []) { int c , i ; for ( i = 0 ; ( c = getchar ()) != EOF ; ++ i ) { if ( c == '\\n' ) { s [ i ] = '.' ; ++ i ; } else s [ i ] = c ; } s [ i ] = '\\0' ; return i ; }","title":"Example 16"},{"location":"Chapter_01/EX1_16/#exercise-1-16-revise-the-main-routine-of-the-longest-line-program-so-it-will-correctly-print-the-length-of-arbitrary-long-input-lines-and-as-much-as-possible-of-the-text","text":"/* Exercise 1-16. Revise the main routine of the longest-line program so it will correctly print the length of arbitrary long input lines, and as much as possible of the text. */ #include <stdio.h> #define MAXlines 500 /* maximum input lines length */ #define MAXLENGTH 50 /* maximum possible text characters to print */ int lineslength ( char lines []); /* print the arbitrary input lines */ int main () { int len ; /* length of an input */ char lines [ MAXlines ]; /* input liness */ int l ; len = lineslength ( lines ); /*by passing lines -> we are calling by reference i.e, pointing to the 0th index address of an array by specifying array name */ printf ( \"%s %d \\n \" , \"length of an input\" , len ); for ( l = 0 ; l < MAXLENGTH ; ++ l ) putchar ( lines [ l ]); return 0 ; } /* getlines: read a lines into s, return length */ int lineslength ( char s []) { int c , i ; for ( i = 0 ; ( c = getchar ()) != EOF ; ++ i ) { if ( c == '\\n' ) { s [ i ] = '.' ; ++ i ; } else s [ i ] = c ; } s [ i ] = '\\0' ; return i ; }","title":"Exercise 1-16. Revise the main routine of the longest-line program so it will correctly print the length of arbitrary long input lines, and as much as possible of the text."},{"location":"Chapter_02/EX2_01/","text":"Exercise 2-1. Write a program to determine the ranges of char, short, int, and long variables, both signed and unsigned, by printing appropriate values from standard headers and by direct computation. Harder if you compute them: determine the ranges of the various floating-point types. /* Exercise 2-1. Write a program to determine the ranges of char, short, int, and long variables, both signed and unsigned, by printing appropriate values from standard headers and by direct computation. Harder if you compute them: determine the ranges of the various floating-point types. */ #include <stdio.h> #include <limits.h> #include <float.h> #define UNSIG_MIN 0 /*minimum value for unsigned datatpes */ int main () { /* initialize all the required variables with the maximum values that it can store by filling in 1's for unsigned and signed(sign bit is set to 0) */ unsigned char uc = ( unsigned char )( ~ 0 ); signed char sc = ( unsigned char )( ~ 0 ) >> 1 ; unsigned short us = ( unsigned short )( ~ 0 ); signed short ss = ( unsigned short )( ~ 0 ) >> 1 ; unsigned int ui = ( unsigned int )( ~ 0 ); signed int si = ( unsigned int )( ~ 0 ) >> 1 ; unsigned long ul = ( unsigned long )( ~ 0 ); signed long sl = ( unsigned long )( ~ 0 ) >> 1 ; printf ( \"ranges of char, short, int, and long variables, both signed and unsigned (standard headers) \\n \" ); printf ( \"------------------------------------------------------------------------------------------- \\n \" ); printf ( \"Range of unsigned char is from : %22d to %22hhu \\n \" , 0 , UCHAR_MAX ); printf ( \"Range of signed char is from : %22hhi to %22hhi \\n \" , SCHAR_MIN , SCHAR_MAX ); printf ( \"Range of unsigned short int is from : %22d to %22hu \\n \" , 0 , USHRT_MAX ); printf ( \"Range of signed short int is from : %22hi to %22hi \\n \" , SHRT_MIN , SHRT_MAX ); printf ( \"Range of unsigned int is from : %22d to %22u \\n \" , 0 , UINT_MAX ); printf ( \"Range of signed int is from : %22i to %22i \\n \" , INT_MIN , INT_MAX ); printf ( \"Range of unsigned long int is from : %22d to %22lu \\n \" , 0 , ULONG_MAX ); printf ( \"Range of signed long int is from : %22li to %22li \\n \" , LONG_MIN , LONG_MAX ); printf ( \"------------------------------------------------------------------------------------------- \\n\\n \" ); printf ( \"ranges of char, short, int, and long variables, both signed and unsigned (direct computation) \\n \" ); printf ( \"-------------------------------------------------------------------------------------------- \\n \" ); printf ( \"Range of unsigned char is from : %22d to %22d \\n \" , UNSIG_MIN , uc ); printf ( \"Range of signed char is from : %22hhi to %22hhi \\n \" , - ( sc + 1 ), sc ); printf ( \"Range of unsigned short int is from : %22d to %22u \\n \" , UNSIG_MIN , us ); printf ( \"Range of signed short int is from : %22hi to %22hi \\n \" , - ( ss + 1 ), ss ); printf ( \"Range of unsigned int is from : %22d to %22u \\n \" , UNSIG_MIN , ui ); printf ( \"Range of signed int is from : %22i to %22i \\n \" , - ( si + 1 ), si ); printf ( \"Range of unsigned long int is from : %22d to %22lu \\n \" , UNSIG_MIN , ul ); printf ( \"Range of signed long int is from : %22li to %22li \\n \" , - ( sl + 1 ), sl ); printf ( \"-------------------------------------------------------------------------------------------- \\n \" ); return 0 ; }","title":"Example 1"},{"location":"Chapter_02/EX2_01/#exercise-2-1-write-a-program-to-determine-the-ranges-of-char-short-int-and-long-variables-both-signed-and-unsigned-by-printing-appropriate-values-from-standard-headers-and-by-direct-computation-harder-if-you-compute-them-determine-the-ranges-of-the-various-floating-point-types","text":"/* Exercise 2-1. Write a program to determine the ranges of char, short, int, and long variables, both signed and unsigned, by printing appropriate values from standard headers and by direct computation. Harder if you compute them: determine the ranges of the various floating-point types. */ #include <stdio.h> #include <limits.h> #include <float.h> #define UNSIG_MIN 0 /*minimum value for unsigned datatpes */ int main () { /* initialize all the required variables with the maximum values that it can store by filling in 1's for unsigned and signed(sign bit is set to 0) */ unsigned char uc = ( unsigned char )( ~ 0 ); signed char sc = ( unsigned char )( ~ 0 ) >> 1 ; unsigned short us = ( unsigned short )( ~ 0 ); signed short ss = ( unsigned short )( ~ 0 ) >> 1 ; unsigned int ui = ( unsigned int )( ~ 0 ); signed int si = ( unsigned int )( ~ 0 ) >> 1 ; unsigned long ul = ( unsigned long )( ~ 0 ); signed long sl = ( unsigned long )( ~ 0 ) >> 1 ; printf ( \"ranges of char, short, int, and long variables, both signed and unsigned (standard headers) \\n \" ); printf ( \"------------------------------------------------------------------------------------------- \\n \" ); printf ( \"Range of unsigned char is from : %22d to %22hhu \\n \" , 0 , UCHAR_MAX ); printf ( \"Range of signed char is from : %22hhi to %22hhi \\n \" , SCHAR_MIN , SCHAR_MAX ); printf ( \"Range of unsigned short int is from : %22d to %22hu \\n \" , 0 , USHRT_MAX ); printf ( \"Range of signed short int is from : %22hi to %22hi \\n \" , SHRT_MIN , SHRT_MAX ); printf ( \"Range of unsigned int is from : %22d to %22u \\n \" , 0 , UINT_MAX ); printf ( \"Range of signed int is from : %22i to %22i \\n \" , INT_MIN , INT_MAX ); printf ( \"Range of unsigned long int is from : %22d to %22lu \\n \" , 0 , ULONG_MAX ); printf ( \"Range of signed long int is from : %22li to %22li \\n \" , LONG_MIN , LONG_MAX ); printf ( \"------------------------------------------------------------------------------------------- \\n\\n \" ); printf ( \"ranges of char, short, int, and long variables, both signed and unsigned (direct computation) \\n \" ); printf ( \"-------------------------------------------------------------------------------------------- \\n \" ); printf ( \"Range of unsigned char is from : %22d to %22d \\n \" , UNSIG_MIN , uc ); printf ( \"Range of signed char is from : %22hhi to %22hhi \\n \" , - ( sc + 1 ), sc ); printf ( \"Range of unsigned short int is from : %22d to %22u \\n \" , UNSIG_MIN , us ); printf ( \"Range of signed short int is from : %22hi to %22hi \\n \" , - ( ss + 1 ), ss ); printf ( \"Range of unsigned int is from : %22d to %22u \\n \" , UNSIG_MIN , ui ); printf ( \"Range of signed int is from : %22i to %22i \\n \" , - ( si + 1 ), si ); printf ( \"Range of unsigned long int is from : %22d to %22lu \\n \" , UNSIG_MIN , ul ); printf ( \"Range of signed long int is from : %22li to %22li \\n \" , - ( sl + 1 ), sl ); printf ( \"-------------------------------------------------------------------------------------------- \\n \" ); return 0 ; }","title":"Exercise 2-1. Write a program to determine the ranges of char, short, int, and long variables, both signed and unsigned, by printing appropriate values from standard headers and by direct computation. Harder if you compute them: determine the ranges of the various floating-point types."},{"location":"Chapter_02/EX2_02/","text":"Exercise 2-2. Write a loop equivalent to the for loop (my_getline_V01) below without using && or || (my_getline_V02). /* Exercise 2-2. Write a loop equivalent to the for loop (my_getline_V01) below without using && or || (my_getline_V02). */ #include <stdio.h> #define MAXLINE 1000 /* maximum input line length */ #define VERSION 2 /* change the version number to either 1 or 2 */ int getline_V01 ( char line1 [], int maxline1 ); int getline_V02 ( char line2 [], int maxline2 ); /* print the input line length */ int main () { int len_V01 , len_V02 ; /* line length */ len_V01 = len_V02 = 0 ; char line [ MAXLINE ]; /* current input line */ if ( VERSION == 1 ) { len_V01 = getline_V01 ( line , MAXLINE ); printf ( \"Line length by V01 : %d \\n \" , len_V01 ); } else if ( VERSION == 2 ) { len_V02 = getline_V02 ( line , MAXLINE ); printf ( \"Line length by V02 : %d \\n \" , len_V02 ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* getline_V01: read a line into s, return length */ int getline_V01 ( char s1 [], int lim1 ) { int c1 , i1 ; for ( i1 = 0 ; i1 < lim1 -1 && ( c1 = getchar ()) != EOF && c1 != '\\n' ; i1 ++ ) s1 [ i1 ] = c1 ; if ( c1 == '\\n' ) { s1 [ i1 ] = c1 ; ++ i1 ; } s1 [ i1 ] = '\\0' ; return i1 ; } /* getline_V02: read a line into s, return length without using && or || */ int getline_V02 ( char s2 [], int lim2 ) { int c2 , i2 ; for ( i2 = 0 ; i2 < lim2 -1 ; i2 ++ ) { if (( c2 = getchar ()) != EOF ) if ( c2 != '\\n' ) s2 [ i2 ] = c2 ; else break ; else break ; } if ( c2 == '\\n' ) { s2 [ i2 ] = c2 ; ++ i2 ; } s2 [ i2 ] = '\\0' ; return i2 ; }","title":"Example 2"},{"location":"Chapter_02/EX2_02/#exercise-2-2-write-a-loop-equivalent-to-the-for-loop-my_getline_v01-below-without-using-or-my_getline_v02","text":"/* Exercise 2-2. Write a loop equivalent to the for loop (my_getline_V01) below without using && or || (my_getline_V02). */ #include <stdio.h> #define MAXLINE 1000 /* maximum input line length */ #define VERSION 2 /* change the version number to either 1 or 2 */ int getline_V01 ( char line1 [], int maxline1 ); int getline_V02 ( char line2 [], int maxline2 ); /* print the input line length */ int main () { int len_V01 , len_V02 ; /* line length */ len_V01 = len_V02 = 0 ; char line [ MAXLINE ]; /* current input line */ if ( VERSION == 1 ) { len_V01 = getline_V01 ( line , MAXLINE ); printf ( \"Line length by V01 : %d \\n \" , len_V01 ); } else if ( VERSION == 2 ) { len_V02 = getline_V02 ( line , MAXLINE ); printf ( \"Line length by V02 : %d \\n \" , len_V02 ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* getline_V01: read a line into s, return length */ int getline_V01 ( char s1 [], int lim1 ) { int c1 , i1 ; for ( i1 = 0 ; i1 < lim1 -1 && ( c1 = getchar ()) != EOF && c1 != '\\n' ; i1 ++ ) s1 [ i1 ] = c1 ; if ( c1 == '\\n' ) { s1 [ i1 ] = c1 ; ++ i1 ; } s1 [ i1 ] = '\\0' ; return i1 ; } /* getline_V02: read a line into s, return length without using && or || */ int getline_V02 ( char s2 [], int lim2 ) { int c2 , i2 ; for ( i2 = 0 ; i2 < lim2 -1 ; i2 ++ ) { if (( c2 = getchar ()) != EOF ) if ( c2 != '\\n' ) s2 [ i2 ] = c2 ; else break ; else break ; } if ( c2 == '\\n' ) { s2 [ i2 ] = c2 ; ++ i2 ; } s2 [ i2 ] = '\\0' ; return i2 ; }","title":"Exercise 2-2. Write a loop equivalent to the for loop (my_getline_V01) below without using &amp;&amp; or || (my_getline_V02)."},{"location":"Chapter_02/EX2_03/","text":"Exercise 2-3. Write a function htoi(s), which converts a string of hexadecimal digits (including an optional 0x or 0X) into its equivalent integer value. The allowable digits are 0 through 9, a through f, and A through F. /* Exercise 2-3. Write a function htoi(s), which converts a string of hexadecimal digits (including an optional 0x or 0X) into its equivalent integer value. The allowable digits are 0 through 9, a through f, and A through F. */ #include <stdio.h> #include <ctype.h> #include <stdbool.h> #define LIMIT 8 /* Maximum no. of Hexadecimal bits */ int get_hex ( char line [], int lim ); unsigned long int hex2int ( char s [], int length ); unsigned long int char2int ( char c ); int main () { int len = 0 ; unsigned long int integer = 0 ; char inp [ LIMIT + 2 ]; printf ( \"Enter the hexadecimal no (Max allowed no. of bits is %d): \\n \" , LIMIT ); len = get_hex ( inp , ( LIMIT + 2 )); integer = hex2int ( inp , len ); printf ( \" \\n Hexadecimal number (Input): %s \\n Equivalent integer number (Output): %lu \\n \" , inp , integer ); return 0 ; } /* getline: read a line (UPPERCASE) into s, return length */ int get_hex ( char s [], int lim ) { int c , i ; for ( i = 0 ; i < lim && ( c = getchar ()) != EOF && c != '\\n' ; ++ i ) s [ i ] = toupper ( c ); s [ i ] = '\\0' ; return i ; } /* hex2int: read array containing heaxadecimal no. and return decimal integer value. */ unsigned long int hex2int ( char s [], int length ) { int bit_pos ; unsigned long int a = 0 ; bool cond = false ; cond = ( s [ 0 ] == '0' && s [ 1 ] == 'X' ); for ( bit_pos = ( length -1 ); ( bit_pos >= ( cond ? 2 : 0 )); -- bit_pos ) /* cond is used to exclude 0X prefix if present in the input*/ a += ( char2int ( s [ bit_pos ])) << ( 4 * ( length -1 - bit_pos )); return a ; } /* convert given character back to its integer form */ unsigned long int char2int ( char c ) { unsigned long int i = 0 ; if ( c >= '0' && c <= '9' ) i = ( unsigned long int ) ( c - '0' ); else { switch ( c ) { case 'A' : i = 10 ; break ; case 'B' : i = 11 ; break ; case 'C' : i = 12 ; break ; case 'D' : i = 13 ; break ; case 'E' : i = 14 ; break ; case 'F' : i = 15 ; break ; default : i = 0 ; break ; } } return i ; }","title":"Example 3"},{"location":"Chapter_02/EX2_03/#exercise-2-3-write-a-function-htois-which-converts-a-string-of-hexadecimal-digits-including-an-optional-0x-or-0x-into-its-equivalent-integer-value-the-allowable-digits-are-0-through-9-a-through-f-and-a-through-f","text":"/* Exercise 2-3. Write a function htoi(s), which converts a string of hexadecimal digits (including an optional 0x or 0X) into its equivalent integer value. The allowable digits are 0 through 9, a through f, and A through F. */ #include <stdio.h> #include <ctype.h> #include <stdbool.h> #define LIMIT 8 /* Maximum no. of Hexadecimal bits */ int get_hex ( char line [], int lim ); unsigned long int hex2int ( char s [], int length ); unsigned long int char2int ( char c ); int main () { int len = 0 ; unsigned long int integer = 0 ; char inp [ LIMIT + 2 ]; printf ( \"Enter the hexadecimal no (Max allowed no. of bits is %d): \\n \" , LIMIT ); len = get_hex ( inp , ( LIMIT + 2 )); integer = hex2int ( inp , len ); printf ( \" \\n Hexadecimal number (Input): %s \\n Equivalent integer number (Output): %lu \\n \" , inp , integer ); return 0 ; } /* getline: read a line (UPPERCASE) into s, return length */ int get_hex ( char s [], int lim ) { int c , i ; for ( i = 0 ; i < lim && ( c = getchar ()) != EOF && c != '\\n' ; ++ i ) s [ i ] = toupper ( c ); s [ i ] = '\\0' ; return i ; } /* hex2int: read array containing heaxadecimal no. and return decimal integer value. */ unsigned long int hex2int ( char s [], int length ) { int bit_pos ; unsigned long int a = 0 ; bool cond = false ; cond = ( s [ 0 ] == '0' && s [ 1 ] == 'X' ); for ( bit_pos = ( length -1 ); ( bit_pos >= ( cond ? 2 : 0 )); -- bit_pos ) /* cond is used to exclude 0X prefix if present in the input*/ a += ( char2int ( s [ bit_pos ])) << ( 4 * ( length -1 - bit_pos )); return a ; } /* convert given character back to its integer form */ unsigned long int char2int ( char c ) { unsigned long int i = 0 ; if ( c >= '0' && c <= '9' ) i = ( unsigned long int ) ( c - '0' ); else { switch ( c ) { case 'A' : i = 10 ; break ; case 'B' : i = 11 ; break ; case 'C' : i = 12 ; break ; case 'D' : i = 13 ; break ; case 'E' : i = 14 ; break ; case 'F' : i = 15 ; break ; default : i = 0 ; break ; } } return i ; }","title":"Exercise 2-3. Write a function htoi(s), which converts a string of hexadecimal digits (including an optional 0x or 0X) into its equivalent integer value. The allowable digits are 0 through 9, a through f, and A through F."},{"location":"Chapter_02/EX2_04/","text":"Exercise 2-4. Write an alternative version of squeeze(s1,s2) that deletes each character in s1 that matches any character in the string s2. /* Exercise 2-4. Write an alternative version of squeeze(s1,s2) that deletes each character in s1 that matches any character in the string s2. */ #include <stdio.h> #define LIMIT 100 /* string length limit */ void get_string ( char str [], int max ); void squeeze ( char s1 [], char s2 []); int main () { char str1 [ LIMIT ]; char str2 [ LIMIT ]; printf ( \"Enter string 1 and press enter = \" ); get_string ( str1 , LIMIT ); printf ( \"Enter string 2 and press enter = \" ); get_string ( str2 , LIMIT ); squeeze ( str1 , str2 ); printf ( \"Squeezed string 1 = %s \\n \" , str1 ); return 0 ; } /* squeeze: delete each character in s1 that matches any character in the string s2 */ void squeeze ( char s1 [], char s2 []) { int i , j , k ; for ( k = 0 ; s2 [ k ] != '\\0' ; k ++ ) { for ( i = j = 0 ; s1 [ i ] != '\\0' ; i ++ ) { if ( s1 [ i ] != s2 [ k ]) s1 [ j ++ ] = s1 [ i ]; } s1 [ j ] = '\\0' ; } } /* get_string: read a string into str */ void get_string ( char str [], int max ) { int i , c ; for ( i = 0 ; i < max -1 && ( c = getchar ()) != EOF && c != '\\n' ; i ++ ) str [ i ] = c ; str [ i ] = '\\0' ; }","title":"Example 4"},{"location":"Chapter_02/EX2_04/#exercise-2-4-write-an-alternative-version-of-squeezes1s2-that-deletes-each-character-in-s1-that-matches-any-character-in-the-string-s2","text":"/* Exercise 2-4. Write an alternative version of squeeze(s1,s2) that deletes each character in s1 that matches any character in the string s2. */ #include <stdio.h> #define LIMIT 100 /* string length limit */ void get_string ( char str [], int max ); void squeeze ( char s1 [], char s2 []); int main () { char str1 [ LIMIT ]; char str2 [ LIMIT ]; printf ( \"Enter string 1 and press enter = \" ); get_string ( str1 , LIMIT ); printf ( \"Enter string 2 and press enter = \" ); get_string ( str2 , LIMIT ); squeeze ( str1 , str2 ); printf ( \"Squeezed string 1 = %s \\n \" , str1 ); return 0 ; } /* squeeze: delete each character in s1 that matches any character in the string s2 */ void squeeze ( char s1 [], char s2 []) { int i , j , k ; for ( k = 0 ; s2 [ k ] != '\\0' ; k ++ ) { for ( i = j = 0 ; s1 [ i ] != '\\0' ; i ++ ) { if ( s1 [ i ] != s2 [ k ]) s1 [ j ++ ] = s1 [ i ]; } s1 [ j ] = '\\0' ; } } /* get_string: read a string into str */ void get_string ( char str [], int max ) { int i , c ; for ( i = 0 ; i < max -1 && ( c = getchar ()) != EOF && c != '\\n' ; i ++ ) str [ i ] = c ; str [ i ] = '\\0' ; }","title":"Exercise 2-4. Write an alternative version of squeeze(s1,s2) that deletes each character in s1 that matches any character in the string s2."},{"location":"Chapter_02/EX2_05/","text":"Exercise 2-5. Write the function any(s1,s2), which returns the first location in a string s1 where any character from the string s2 occurs, or -1 if s1 contains no characters from s2. (The standard library function strpbrk does the same job but returns a pointer to the location.) /* Exercise 2-5. Write the function any(s1,s2), which returns the first location in a string s1 where any character from the string s2 occurs, or -1 if s1 contains no characters from s2. (The standard library function strpbrk does the same job but returns a pointer to the location.) */ #include <stdio.h> #define LIMIT 100 /* string length limit */ void get_string ( char str [], int max ); int any ( char s1 [], char s2 []); int main () { char str1 [ LIMIT ]; char str2 [ LIMIT ]; int value = -1 ; printf ( \"Enter string 1 and press enter = \" ); get_string ( str1 , LIMIT ); printf ( \"Enter string 2 and press enter = \" ); get_string ( str2 , LIMIT ); value = any ( str1 , str2 ); if ( value != -1 ) printf ( \"First location in string 1 is = %d, character = %c \\n \" , value , str1 [ value ]); else printf ( \"No match found, value = %d \\n \" , value ); return 0 ; } /* any: returns the first location in a string s1 where any character from the string s2 occurs, or -1 if s1 contains no characters from s2 */ int any ( char s1 [], char s2 []) { int i , j ; for ( i = 0 ; s1 [ i ] != '\\0' ; i ++ ) { for ( j = 0 ; s2 [ j ] != '\\0' ; j ++ ) { if ( s1 [ i ] == s2 [ j ]) return i ; } } return -1 ; } /* get_string: read a string into str */ void get_string ( char str [], int max ) { int i , c ; for ( i = 0 ; i < max -1 && ( c = getchar ()) != EOF && c != '\\n' ; i ++ ) str [ i ] = c ; str [ i ] = '\\0' ; }","title":"Example 5"},{"location":"Chapter_02/EX2_05/#exercise-2-5-write-the-function-anys1s2-which-returns-the-first-location-in-a-string-s1-where-any-character-from-the-string-s2-occurs-or-1-if-s1-contains-no-characters-from-s2-the-standard-library-function-strpbrk-does-the-same-job-but-returns-a-pointer-to-the-location","text":"/* Exercise 2-5. Write the function any(s1,s2), which returns the first location in a string s1 where any character from the string s2 occurs, or -1 if s1 contains no characters from s2. (The standard library function strpbrk does the same job but returns a pointer to the location.) */ #include <stdio.h> #define LIMIT 100 /* string length limit */ void get_string ( char str [], int max ); int any ( char s1 [], char s2 []); int main () { char str1 [ LIMIT ]; char str2 [ LIMIT ]; int value = -1 ; printf ( \"Enter string 1 and press enter = \" ); get_string ( str1 , LIMIT ); printf ( \"Enter string 2 and press enter = \" ); get_string ( str2 , LIMIT ); value = any ( str1 , str2 ); if ( value != -1 ) printf ( \"First location in string 1 is = %d, character = %c \\n \" , value , str1 [ value ]); else printf ( \"No match found, value = %d \\n \" , value ); return 0 ; } /* any: returns the first location in a string s1 where any character from the string s2 occurs, or -1 if s1 contains no characters from s2 */ int any ( char s1 [], char s2 []) { int i , j ; for ( i = 0 ; s1 [ i ] != '\\0' ; i ++ ) { for ( j = 0 ; s2 [ j ] != '\\0' ; j ++ ) { if ( s1 [ i ] == s2 [ j ]) return i ; } } return -1 ; } /* get_string: read a string into str */ void get_string ( char str [], int max ) { int i , c ; for ( i = 0 ; i < max -1 && ( c = getchar ()) != EOF && c != '\\n' ; i ++ ) str [ i ] = c ; str [ i ] = '\\0' ; }","title":"Exercise 2-5. Write the function any(s1,s2), which returns the first location in a string s1 where any character from the string s2 occurs, or -1 if s1 contains no characters from s2. (The standard library function strpbrk does the same job but returns a pointer to the location.)"},{"location":"Chapter_02/EX2_06/","text":"Exercise 2-6. Write a function setbits(x,p,n,y) that returns x with the n bits that begin at position p set to the rightmost n bits of y, leaving the other bits unchanged. /* Exercise 2-6. Write a function setbits(x,p,n,y) that returns x with the n bits that begin at position p set to the rightmost n bits of y, leaving the other bits unchanged. */ #include <stdio.h> unsigned setbits ( unsigned x , int p , int n , unsigned y ); int main () { unsigned x = 0x00F0 ; unsigned y = 0x0002 ; printf ( \"x = %d \\n y = %d \\n \" , x , y ); x = setbits ( x , 6 , 4 , y ); printf ( \"modified x = %d \\n \" , x ); return 0 ; } unsigned setbits ( unsigned x , int p , int n , unsigned y ) { unsigned temp = 0 ; temp = x & ~ (( ~ ( ~ 0U << n )) << ( p + 1 - n )); return (( temp ) | ( y << ( p + 1 - n ))); } /* Example snippet walkthrough. ---------------------------- x = 0x00F0 = 0000 0000 1111 0000 y = 0x0002 = 0000 0000 0000 0010 p = 6 n = 4 temp = 0000 0000 1000 0000 --> sets n bits to 0 from p, unaltered elsewhere. (y << (p + 1 - n)) = 0000 0000 0001 0000 --> shifts rightmost n bits of y towards p. output = 0000 0000 1001 0000 --> logical or previous 2 steps gives us output. */","title":"Example 6"},{"location":"Chapter_02/EX2_06/#exercise-2-6-write-a-function-setbitsxpny-that-returns-x-with-the-n-bits-that-begin-at-position-p-set-to-the-rightmost-n-bits-of-y-leaving-the-other-bits-unchanged","text":"/* Exercise 2-6. Write a function setbits(x,p,n,y) that returns x with the n bits that begin at position p set to the rightmost n bits of y, leaving the other bits unchanged. */ #include <stdio.h> unsigned setbits ( unsigned x , int p , int n , unsigned y ); int main () { unsigned x = 0x00F0 ; unsigned y = 0x0002 ; printf ( \"x = %d \\n y = %d \\n \" , x , y ); x = setbits ( x , 6 , 4 , y ); printf ( \"modified x = %d \\n \" , x ); return 0 ; } unsigned setbits ( unsigned x , int p , int n , unsigned y ) { unsigned temp = 0 ; temp = x & ~ (( ~ ( ~ 0U << n )) << ( p + 1 - n )); return (( temp ) | ( y << ( p + 1 - n ))); } /* Example snippet walkthrough. ---------------------------- x = 0x00F0 = 0000 0000 1111 0000 y = 0x0002 = 0000 0000 0000 0010 p = 6 n = 4 temp = 0000 0000 1000 0000 --> sets n bits to 0 from p, unaltered elsewhere. (y << (p + 1 - n)) = 0000 0000 0001 0000 --> shifts rightmost n bits of y towards p. output = 0000 0000 1001 0000 --> logical or previous 2 steps gives us output. */","title":"Exercise 2-6. Write a function setbits(x,p,n,y) that returns x with the n bits that begin at position p set to the rightmost n bits of y, leaving the other bits unchanged."},{"location":"Chapter_02/EX2_07/","text":"Exercise 2-7. Write a function invert(x,p,n) that returns x with the n bits that begin at position p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged. /* Exercise 2-7. Write a function invert(x,p,n) that returns x with the n bits that begin at position p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged. */ #include <stdio.h> unsigned invert ( unsigned x , int p , int n ); int main () { unsigned x = 0xABCD ; printf ( \"x = %d \\n \" , x ); x = invert ( x , 6 , 4 ); printf ( \"modified x = %d \\n \" , x ); return 0 ; } unsigned invert ( unsigned x , int p , int n ) { unsigned temp = 0 ; temp = (( ~ ( ~ 0U << n )) << ( p + 1 - n )); return (( x ) ^ ( temp )); }","title":"Example 7"},{"location":"Chapter_02/EX2_07/#exercise-2-7-write-a-function-invertxpn-that-returns-x-with-the-n-bits-that-begin-at-position-p-inverted-ie-1-changed-into-0-and-vice-versa-leaving-the-others-unchanged","text":"/* Exercise 2-7. Write a function invert(x,p,n) that returns x with the n bits that begin at position p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged. */ #include <stdio.h> unsigned invert ( unsigned x , int p , int n ); int main () { unsigned x = 0xABCD ; printf ( \"x = %d \\n \" , x ); x = invert ( x , 6 , 4 ); printf ( \"modified x = %d \\n \" , x ); return 0 ; } unsigned invert ( unsigned x , int p , int n ) { unsigned temp = 0 ; temp = (( ~ ( ~ 0U << n )) << ( p + 1 - n )); return (( x ) ^ ( temp )); }","title":"Exercise 2-7. Write a function invert(x,p,n) that returns x with the n bits that begin at position p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged."},{"location":"Chapter_02/EX2_08/","text":"Exercise 2-8. Write a function rightrot(x,n) that returns the value of the integer x rotated to the right by n positions. /* Exercise 2-8. Write a function rightrot(x,n) that returns the value of the integer x rotated to the right by n positions. */ #include <stdio.h> unsigned rightrot ( unsigned x , int n ); int unsignedlength ( void ); int main () { unsigned x = 99 ; printf ( \"x = %d \\n \" , x ); x = rightrot ( x , 5 ); printf ( \"modified x = %i \\n \" , x ); return 0 ; } unsigned rightrot ( unsigned x , int n ) { int length = unsignedlength (); printf ( \"bit length of x = %d \\n \" , length ); return (( x >> n ) | ((( x ) & ( ~ ( ~ 0U << n ))) << ( length - n ))); } /* bitlength: count no of bits in x */ int unsignedlength ( void ) { int b ; unsigned y ; y = ( ~ 0 ); /* sets every bit of y to 1*/ for ( b = 0 ; y != 0 ; y >>= 1 ) b ++ ; return b ; }","title":"Example 8"},{"location":"Chapter_02/EX2_08/#exercise-2-8-write-a-function-rightrotxn-that-returns-the-value-of-the-integer-x-rotated-to-the-right-by-n-positions","text":"/* Exercise 2-8. Write a function rightrot(x,n) that returns the value of the integer x rotated to the right by n positions. */ #include <stdio.h> unsigned rightrot ( unsigned x , int n ); int unsignedlength ( void ); int main () { unsigned x = 99 ; printf ( \"x = %d \\n \" , x ); x = rightrot ( x , 5 ); printf ( \"modified x = %i \\n \" , x ); return 0 ; } unsigned rightrot ( unsigned x , int n ) { int length = unsignedlength (); printf ( \"bit length of x = %d \\n \" , length ); return (( x >> n ) | ((( x ) & ( ~ ( ~ 0U << n ))) << ( length - n ))); } /* bitlength: count no of bits in x */ int unsignedlength ( void ) { int b ; unsigned y ; y = ( ~ 0 ); /* sets every bit of y to 1*/ for ( b = 0 ; y != 0 ; y >>= 1 ) b ++ ; return b ; }","title":"Exercise 2-8. Write a function rightrot(x,n) that returns the value of the integer x rotated to the right by n positions."},{"location":"Chapter_02/EX2_09/","text":"Exercise 2-9. In a two's complement number system, x &= (x-1) deletes the rightmost 1-bit in x. Explain why. Use this observation to write a faster version of bitcount. /* Exercise 2-9. In a two's complement number system, x &= (x-1) deletes the rightmost 1-bit in x. Explain why. Use this observation to write a faster version of bitcount. */ #include <stdio.h> #define VERSION 2 /* change the version number to either 1 or 2 */ int bitcount_V01 ( unsigned x ); int bitcount_V02 ( unsigned x ); int main () { int x = 0xF9F5 ; int len_V01 , len_V02 ; if ( VERSION == 1 ) { len_V01 = bitcount_V01 ( x ); printf ( \"bit count by V01 : %d \\n \" , len_V01 ); } else if ( VERSION == 2 ) { len_V02 = bitcount_V02 ( x ); printf ( \"bit count by V02 : %d \\n \" , len_V02 ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* bitcount_V01: count 1 bits in x */ int bitcount_V01 ( unsigned x ) { int b ; for ( b = 0 ; x != 0 ; x >>= 1 ) if ( x & 01 ) b ++ ; return b ; } /* bitcount_V02: count 1 bits in x -> faster version to bitcount_V01 */ int bitcount_V02 ( unsigned x ) { int b ; for ( b = 0 ; x != 0 ; x &= ( x - 1 )) b ++ ; return b ; }","title":"Example 9"},{"location":"Chapter_02/EX2_09/#exercise-2-9-in-a-twos-complement-number-system-x-x-1-deletes-the-rightmost-1-bit-in-x-explain-why-use-this-observation-to-write-a-faster-version-of-bitcount","text":"/* Exercise 2-9. In a two's complement number system, x &= (x-1) deletes the rightmost 1-bit in x. Explain why. Use this observation to write a faster version of bitcount. */ #include <stdio.h> #define VERSION 2 /* change the version number to either 1 or 2 */ int bitcount_V01 ( unsigned x ); int bitcount_V02 ( unsigned x ); int main () { int x = 0xF9F5 ; int len_V01 , len_V02 ; if ( VERSION == 1 ) { len_V01 = bitcount_V01 ( x ); printf ( \"bit count by V01 : %d \\n \" , len_V01 ); } else if ( VERSION == 2 ) { len_V02 = bitcount_V02 ( x ); printf ( \"bit count by V02 : %d \\n \" , len_V02 ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* bitcount_V01: count 1 bits in x */ int bitcount_V01 ( unsigned x ) { int b ; for ( b = 0 ; x != 0 ; x >>= 1 ) if ( x & 01 ) b ++ ; return b ; } /* bitcount_V02: count 1 bits in x -> faster version to bitcount_V01 */ int bitcount_V02 ( unsigned x ) { int b ; for ( b = 0 ; x != 0 ; x &= ( x - 1 )) b ++ ; return b ; }","title":"Exercise 2-9. In a two's complement number system, x &amp;= (x-1) deletes the rightmost 1-bit in x. Explain why. Use this observation to write a faster version of bitcount."},{"location":"Chapter_02/EX2_10/","text":"Exercise 2-10. Rewrite the function lower, which converts upper case letters to lower case, with a conditional expression instead of if-else. /* Exercise 2-10. Rewrite the function lower, which converts upper case letters to lower case, with a conditional expression instead of if-else. */ #include <stdio.h> #define VERSION 2 /* change the version number to either 1 or 2 */ int lower_V01 ( int c ); int lower_V02 ( int c ); int main () { int c = 'Z' ; int low_V01 , low_V02 ; if ( VERSION == 1 ) { low_V01 = lower_V01 ( c ); printf ( \"lower case of %c if %c (V01) \\n \" , c , low_V01 ); } else if ( VERSION == 2 ) { low_V02 = lower_V02 ( c ); printf ( \"lower case of %c if %c (V02) \\n \" , c , low_V02 ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* lower_V01: convert c to lower case; ASCII only */ int lower_V01 ( int c ) { if ( c >= 'A' && c <= 'Z' ) return c + 'a' - 'A' ; else return c ; } /* lower_V02: convert c to lower case; ASCII only w/0 if-else, using conditionals */ int lower_V02 ( int c ) { return ( c >= 'A' && c <= 'Z' ) ? ( c + 'a' - 'A' ) : ( c ); }","title":"Example 10"},{"location":"Chapter_02/EX2_10/#exercise-2-10-rewrite-the-function-lower-which-converts-upper-case-letters-to-lower-case-with-a-conditional-expression-instead-of-if-else","text":"/* Exercise 2-10. Rewrite the function lower, which converts upper case letters to lower case, with a conditional expression instead of if-else. */ #include <stdio.h> #define VERSION 2 /* change the version number to either 1 or 2 */ int lower_V01 ( int c ); int lower_V02 ( int c ); int main () { int c = 'Z' ; int low_V01 , low_V02 ; if ( VERSION == 1 ) { low_V01 = lower_V01 ( c ); printf ( \"lower case of %c if %c (V01) \\n \" , c , low_V01 ); } else if ( VERSION == 2 ) { low_V02 = lower_V02 ( c ); printf ( \"lower case of %c if %c (V02) \\n \" , c , low_V02 ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* lower_V01: convert c to lower case; ASCII only */ int lower_V01 ( int c ) { if ( c >= 'A' && c <= 'Z' ) return c + 'a' - 'A' ; else return c ; } /* lower_V02: convert c to lower case; ASCII only w/0 if-else, using conditionals */ int lower_V02 ( int c ) { return ( c >= 'A' && c <= 'Z' ) ? ( c + 'a' - 'A' ) : ( c ); }","title":"Exercise 2-10. Rewrite the function lower, which converts upper case letters to lower case, with a conditional expression instead of if-else."},{"location":"Chapter_03/EX3_01/","text":"Exercise 3-1. Our binary search makes two tests inside the loop, when one would suffice (at the price of more tests outside.) Write a version with only one test inside the loop and measure the difference in run-time. /* Exercise 3-1. Our binary search makes two tests inside the loop, when one would suffice (at the price of more tests outside.) Write a version with only one test inside the loop and measure the difference in run-time. */ #include <stdio.h> #include <time.h> #define VERSION 2 /* change the version number to either 1 or 2 */ #define CHECK_RUNTIME 1 /* change to 0 to turn off runtime check else for runtime check set value to > 0 */ int binsearch_V01 ( int x , int v [], int n ); int binsearch_V02 ( int x , int v [], int n ); double runtime_diff ( int x , int v [], int n ); int main () { int x = 11 ; int n = 11 ; int v [ 11 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 }; int found_V01 , found_V02 ; if ( VERSION == 1 ) { found_V01 = binsearch_V01 ( x , v , n ); if ( found_V01 > 0 ) printf ( \"Position of element %d in array v[] is %d (V01) \\n \" , x , found_V01 ); else printf ( \"Element %d not found \\n \" , x ); } else if ( VERSION == 2 ) { found_V02 = binsearch_V02 ( x , v , n ); if ( found_V02 > 0 ) printf ( \"Position of element %d in array v[] is %d (V02) \\n \" , x , found_V02 ); else printf ( \"Element %d not found \\n \" , x ); } else printf ( \"Entered version number is not correct \\n \" ); if ( CHECK_RUNTIME > 0 ) { /* runtime difference b/w 2 versions */ printf ( \"runtime difference b/w V01 and V02 (V01 - V02) ran over 10,000 times is = %f \\n \" , runtime_diff ( x , v , n )); } return 0 ; } /* binsearch_V01: find x in v[0] <= v[1] <= ... <= v[n-1] */ int binsearch_V01 ( int x , int v [], int n ) { int low , high , mid ; low = 0 ; high = n - 1 ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( x < v [ mid ]) high = mid - 1 ; else if ( x > v [ mid ]) low = mid + 1 ; else /* found match */ return mid ; } return -1 ; /* no match */ } /* binsearch_V02: find x in v[0] <= v[1] <= ... <= v[n-1] :- version with only one test inside the loop */ int binsearch_V02 ( int x , int v [], int n ) { int low , high , mid ; low = 0 ; high = n - 1 ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( x < v [ mid ]) high = mid - 1 ; else low = mid + 1 ; } if ( low >= high ) return low -1 ; else return -1 ; } double runtime_diff ( int x , int v [], int n ) { int average = 10000 ; int i ; double time_spent1 = 0 ; double time_spent2 = 0 ; for ( i = 0 ; i < average ; i ++ ) { clock_t begin1 = clock (); binsearch_V01 ( x , v , n ); clock_t end1 = clock (); time_spent1 += ( double )( end1 - begin1 ) / CLOCKS_PER_SEC ; clock_t begin2 = clock (); binsearch_V02 ( x , v , n ); clock_t end2 = clock (); time_spent2 += ( double )( end2 - begin2 ) / CLOCKS_PER_SEC ; } return ( time_spent1 - time_spent2 ); }","title":"Example 1"},{"location":"Chapter_03/EX3_01/#exercise-3-1-our-binary-search-makes-two-tests-inside-the-loop-when-one-would-suffice-at-the-price-of-more-tests-outside-write-a-version-with-only-one-test-inside-the-loop-and-measure-the-difference-in-run-time","text":"/* Exercise 3-1. Our binary search makes two tests inside the loop, when one would suffice (at the price of more tests outside.) Write a version with only one test inside the loop and measure the difference in run-time. */ #include <stdio.h> #include <time.h> #define VERSION 2 /* change the version number to either 1 or 2 */ #define CHECK_RUNTIME 1 /* change to 0 to turn off runtime check else for runtime check set value to > 0 */ int binsearch_V01 ( int x , int v [], int n ); int binsearch_V02 ( int x , int v [], int n ); double runtime_diff ( int x , int v [], int n ); int main () { int x = 11 ; int n = 11 ; int v [ 11 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 }; int found_V01 , found_V02 ; if ( VERSION == 1 ) { found_V01 = binsearch_V01 ( x , v , n ); if ( found_V01 > 0 ) printf ( \"Position of element %d in array v[] is %d (V01) \\n \" , x , found_V01 ); else printf ( \"Element %d not found \\n \" , x ); } else if ( VERSION == 2 ) { found_V02 = binsearch_V02 ( x , v , n ); if ( found_V02 > 0 ) printf ( \"Position of element %d in array v[] is %d (V02) \\n \" , x , found_V02 ); else printf ( \"Element %d not found \\n \" , x ); } else printf ( \"Entered version number is not correct \\n \" ); if ( CHECK_RUNTIME > 0 ) { /* runtime difference b/w 2 versions */ printf ( \"runtime difference b/w V01 and V02 (V01 - V02) ran over 10,000 times is = %f \\n \" , runtime_diff ( x , v , n )); } return 0 ; } /* binsearch_V01: find x in v[0] <= v[1] <= ... <= v[n-1] */ int binsearch_V01 ( int x , int v [], int n ) { int low , high , mid ; low = 0 ; high = n - 1 ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( x < v [ mid ]) high = mid - 1 ; else if ( x > v [ mid ]) low = mid + 1 ; else /* found match */ return mid ; } return -1 ; /* no match */ } /* binsearch_V02: find x in v[0] <= v[1] <= ... <= v[n-1] :- version with only one test inside the loop */ int binsearch_V02 ( int x , int v [], int n ) { int low , high , mid ; low = 0 ; high = n - 1 ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( x < v [ mid ]) high = mid - 1 ; else low = mid + 1 ; } if ( low >= high ) return low -1 ; else return -1 ; } double runtime_diff ( int x , int v [], int n ) { int average = 10000 ; int i ; double time_spent1 = 0 ; double time_spent2 = 0 ; for ( i = 0 ; i < average ; i ++ ) { clock_t begin1 = clock (); binsearch_V01 ( x , v , n ); clock_t end1 = clock (); time_spent1 += ( double )( end1 - begin1 ) / CLOCKS_PER_SEC ; clock_t begin2 = clock (); binsearch_V02 ( x , v , n ); clock_t end2 = clock (); time_spent2 += ( double )( end2 - begin2 ) / CLOCKS_PER_SEC ; } return ( time_spent1 - time_spent2 ); }","title":"Exercise 3-1. Our binary search makes two tests inside the loop, when one would suffice (at the price of more tests outside.) Write a version with only one test inside the loop and measure the difference in run-time."},{"location":"Chapter_03/EX3_02/","text":"Exercise 3-2. Write a function escape(s,t) that converts characters like newline and tab into visible escape sequences like \\n and \\t as it copies the string t to s. Use a switch. Write a function for the other direction as well, converting escape sequences into the real characters. /* Exercise 3-2. Write a function escape(s,t) that converts characters like newline and tab into visible escape sequences like \\n and \\t as it copies the string t to s. Use a switch. Write a function for the other direction as well, converting escape sequences into the real characters. */ #include <stdio.h> #include <string.h> #define LIMIT 200 void escape ( char s [], char t []); void escape_reverse ( char s [], char t []); int main () { char s [ LIMIT ]; char t [ LIMIT / 2 ] = \"a bc d t\" ; escape ( s , t ); /* 's' is modified in-place, by using 't' as input*/ printf ( \"converting escape characters to visible escape sequences. \\n \" ); printf ( \"--------------------------------------------------------- \\n \" ); printf ( \"input string t = '%s' \\n output string s = '%s' \\n\\n \" , t , s ); escape_reverse ( s , t ); /* 't' is modified in-place by using modified 's' as input*/ printf ( \"converting visible escape sequences to real characters. \\n \" ); printf ( \"--------------------------------------------------------- \\n \" ); printf ( \"input string s = '%s' \\n output string t = '%s' \\n \" , s , t ); return 0 ; } void escape ( char s [], char t []) { int i , j , c ; for ( i = 0 , j = 0 ; i < (( int ) strlen ( t )); i ++ , j ++ ) { c = t [ i ]; switch ( c ) { case '\\t' : s [ j ] = '\\\\' ; j ++ ; s [ j ] = 't' ; break ; case '\\n' : s [ j ] = '\\\\' ; j ++ ; s [ j ] = '\\n' ; break ; default : s [ j ] = t [ i ]; break ; } } s [ j ] = '\\0' ; } void escape_reverse ( char s [], char t []) { int i , j , c ; for ( i = 0 , j = 0 ; i < (( int ) strlen ( s )); i ++ , j ++ ) { c = s [ i ]; switch ( c ) { case '\\\\' : t [ j ] = (( s [ ++ i ] == 't' ) ? '\\t' : (( s [ ++ i ] == 'n' ) ? '\\n' : '\\\\' )); break ; default : t [ j ] = s [ i ]; break ; } } t [ j ] = '\\0' ; }","title":"Example 2"},{"location":"Chapter_03/EX3_02/#exercise-3-2-write-a-function-escapest-that-converts-characters-like-newline-and-tab-into-visible-escape-sequences-like-n-and-t-as-it-copies-the-string-t-to-s-use-a-switch-write-a-function-for-the-other-direction-as-well-converting-escape-sequences-into-the-real-characters","text":"/* Exercise 3-2. Write a function escape(s,t) that converts characters like newline and tab into visible escape sequences like \\n and \\t as it copies the string t to s. Use a switch. Write a function for the other direction as well, converting escape sequences into the real characters. */ #include <stdio.h> #include <string.h> #define LIMIT 200 void escape ( char s [], char t []); void escape_reverse ( char s [], char t []); int main () { char s [ LIMIT ]; char t [ LIMIT / 2 ] = \"a bc d t\" ; escape ( s , t ); /* 's' is modified in-place, by using 't' as input*/ printf ( \"converting escape characters to visible escape sequences. \\n \" ); printf ( \"--------------------------------------------------------- \\n \" ); printf ( \"input string t = '%s' \\n output string s = '%s' \\n\\n \" , t , s ); escape_reverse ( s , t ); /* 't' is modified in-place by using modified 's' as input*/ printf ( \"converting visible escape sequences to real characters. \\n \" ); printf ( \"--------------------------------------------------------- \\n \" ); printf ( \"input string s = '%s' \\n output string t = '%s' \\n \" , s , t ); return 0 ; } void escape ( char s [], char t []) { int i , j , c ; for ( i = 0 , j = 0 ; i < (( int ) strlen ( t )); i ++ , j ++ ) { c = t [ i ]; switch ( c ) { case '\\t' : s [ j ] = '\\\\' ; j ++ ; s [ j ] = 't' ; break ; case '\\n' : s [ j ] = '\\\\' ; j ++ ; s [ j ] = '\\n' ; break ; default : s [ j ] = t [ i ]; break ; } } s [ j ] = '\\0' ; } void escape_reverse ( char s [], char t []) { int i , j , c ; for ( i = 0 , j = 0 ; i < (( int ) strlen ( s )); i ++ , j ++ ) { c = s [ i ]; switch ( c ) { case '\\\\' : t [ j ] = (( s [ ++ i ] == 't' ) ? '\\t' : (( s [ ++ i ] == 'n' ) ? '\\n' : '\\\\' )); break ; default : t [ j ] = s [ i ]; break ; } } t [ j ] = '\\0' ; }","title":"Exercise 3-2. Write a function escape(s,t) that converts characters like newline and tab into visible escape sequences like \\n and \\t as it copies the string t to s. Use a switch. Write a function for the other direction as well, converting escape sequences into the real characters."},{"location":"Chapter_03/EX3_03/","text":"Exercise 3-3. Write a function expand(s1,s2) that expands shorthand notations like a-z in the string s1 into the equivalent complete list abc...xyz in s2. Allow for letters of either case and digits, and be prepared to handle cases like a-b-c and a-z0-9 and -a-z. Arrange that a leading or trailing - is taken literally. /* Exercise 3-3. Write a function expand(s1,s2) that expands shorthand notations like a-z in the string s1 into the equivalent complete list abc...xyz in s2. Allow for letters of either case and digits, and be prepared to handle cases like a-b-c and a-z0-9 and -a-z. Arrange that a leading or trailing - is taken literally. */ #include <stdio.h> #include <string.h> #define LIMIT 200 void expand ( char s1 [], char s2 []); int main () { char s1 [ LIMIT / 2 ] = \"-a-d0-9A-Da-b-c-d-\" ; char s2 [ LIMIT ]; expand ( s1 , s2 ); /* 's2' is modified in-place, by using 's1' as input*/ printf ( \"converting shorthand notations to equivalent complete list. \\n \" ); printf ( \"----------------------------------------------------------- \\n \" ); printf ( \"input string s1 = '%s' \\n output string s2 = '%s' \\n\\n \" , s1 , s2 ); return 0 ; } void expand ( char s1 [], char s2 []) { int i , j , k , c ; for ( i = 0 , j = 0 ; i < (( int ) strlen ( s1 )); i ++ ) { c = s1 [ i ]; switch ( c ) { case '-' : if ( i > 0 ) for ( k = s1 [ i -1 ]; k <= s1 [ i + 1 ]; k ++ , j ++ ) { if ( s2 [ j -1 ] == k ) j -- ; else s2 [ j ] = k ; } break ; default : break ; } } s2 [ j ] = '\\0' ; }","title":"Example 3"},{"location":"Chapter_03/EX3_03/#exercise-3-3-write-a-function-expands1s2-that-expands-shorthand-notations-like-a-z-in-the-string-s1-into-the-equivalent-complete-list-abcxyz-in-s2-allow-for-letters-of-either-case-and-digits-and-be-prepared-to-handle-cases-like-a-b-c-and-a-z0-9-and-a-z-arrange-that-a-leading-or-trailing-is-taken-literally","text":"/* Exercise 3-3. Write a function expand(s1,s2) that expands shorthand notations like a-z in the string s1 into the equivalent complete list abc...xyz in s2. Allow for letters of either case and digits, and be prepared to handle cases like a-b-c and a-z0-9 and -a-z. Arrange that a leading or trailing - is taken literally. */ #include <stdio.h> #include <string.h> #define LIMIT 200 void expand ( char s1 [], char s2 []); int main () { char s1 [ LIMIT / 2 ] = \"-a-d0-9A-Da-b-c-d-\" ; char s2 [ LIMIT ]; expand ( s1 , s2 ); /* 's2' is modified in-place, by using 's1' as input*/ printf ( \"converting shorthand notations to equivalent complete list. \\n \" ); printf ( \"----------------------------------------------------------- \\n \" ); printf ( \"input string s1 = '%s' \\n output string s2 = '%s' \\n\\n \" , s1 , s2 ); return 0 ; } void expand ( char s1 [], char s2 []) { int i , j , k , c ; for ( i = 0 , j = 0 ; i < (( int ) strlen ( s1 )); i ++ ) { c = s1 [ i ]; switch ( c ) { case '-' : if ( i > 0 ) for ( k = s1 [ i -1 ]; k <= s1 [ i + 1 ]; k ++ , j ++ ) { if ( s2 [ j -1 ] == k ) j -- ; else s2 [ j ] = k ; } break ; default : break ; } } s2 [ j ] = '\\0' ; }","title":"Exercise 3-3. Write a function expand(s1,s2) that expands shorthand notations like a-z in the string s1 into the equivalent complete list abc...xyz in s2. Allow for letters of either case and digits, and be prepared to handle cases like a-b-c and a-z0-9 and -a-z. Arrange that a leading or trailing - is taken literally."},{"location":"Chapter_03/EX3_04/","text":"Exercise 3-4. In a two's complement number representation, our version of itoa does not handle the largest negative number, that is, the value of n equal to -(2^(wordsize-1)). Explain why not. Modify it to print that value correctly, regardless of the machine on which it runs. /* Exercise 3-4. In a two's complement number representation, our version of itoa does not handle the largest negative number, that is, the value of n equal to -(2^(wordsize-1)). Explain why not. Modify it to print that value correctly, regardless of the machine on which it runs.*/ #include <stdio.h> #include <string.h> #include <limits.h> #define LIMIT 100 #define VERSION 2 /* change the version number to either 1 or 2 */ void reverse ( char s []); void itoa_V01 ( int n , char s []); void itoa_V02 ( int n , char s []); int main () { int n = INT_MIN ; char s [ LIMIT ]; if ( VERSION == 1 ) { itoa_V01 ( n , s ); printf ( \"'%s' (V01) \\n \" , s ); } else if ( VERSION == 2 ) { itoa_V02 ( n , s ); printf ( \"'%s' (V02) \\n \" , s ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* reverse: reverse string s in place */ void reverse ( char s []) { int c , i , j ; for ( i = 0 , j = strlen ( s ) -1 ; i < j ; i ++ , j -- ) c = s [ i ], s [ i ] = s [ j ], s [ j ] = c ; } /* itoa_V01: convert n to characters in s */ void itoa_V01 ( int n , char s []) { int i , sign ; if (( sign = n ) < 0 ) /* record sign */ n = - n ; /* make n positive */ i = 0 ; do { /* generate digits in reverse order */ s [ i ++ ] = n % 10 + '0' ; /* get next digit */ } while (( n /= 10 ) > 0 ); /* delete it */ if ( sign < 0 ) s [ i ++ ] = '-' ; s [ i ] = '\\0' ; reverse ( s ); } /* itoa_V02: convert n to characters in s -> handles the largest negative number, that is, the value of n equal to -(2^(wordsize-1)) */ void itoa_V02 ( int n , char s []) { int i , sign ; if (( sign = n ) < 0 ) /* record sign */ n = - ( n + 1 ); /* make n positive (and add 1 to avoid overflow for INT_MIN)*/ i = 0 ; do { /* generate digits in reverse order */ s [ i ++ ] = n % 10 + '0' ; /* get next digit */ } while (( n /= 10 ) > 0 ); /* delete it */ if ( sign < 0 ) { s [ i ++ ] = '-' ; s [ 0 ] ++ ; /* 0th element is Incremented by 1 to compensate for the addition that we did above */ } s [ i ] = '\\0' ; reverse ( s ); } /* Reason itoa_V01 won't work for n = INT_MIN (-(2^(wordsize-1))) -------------------------------------------------------------------------------------------------------- INT_MIN = -2147483648; INT_MAX = 2147483647; so when we do n = -n, overflow occurs, because n cannot store 2147483648 (It can only store 2147483647) -------------------------------------------------------------------------------------------------------- */","title":"Example 4"},{"location":"Chapter_03/EX3_04/#exercise-3-4-in-a-twos-complement-number-representation-our-version-of-itoa-does-not-handle-the-largest-negative-number-that-is-the-value-of-n-equal-to-2wordsize-1-explain-why-not-modify-it-to-print-that-value-correctly-regardless-of-the-machine-on-which-it-runs","text":"/* Exercise 3-4. In a two's complement number representation, our version of itoa does not handle the largest negative number, that is, the value of n equal to -(2^(wordsize-1)). Explain why not. Modify it to print that value correctly, regardless of the machine on which it runs.*/ #include <stdio.h> #include <string.h> #include <limits.h> #define LIMIT 100 #define VERSION 2 /* change the version number to either 1 or 2 */ void reverse ( char s []); void itoa_V01 ( int n , char s []); void itoa_V02 ( int n , char s []); int main () { int n = INT_MIN ; char s [ LIMIT ]; if ( VERSION == 1 ) { itoa_V01 ( n , s ); printf ( \"'%s' (V01) \\n \" , s ); } else if ( VERSION == 2 ) { itoa_V02 ( n , s ); printf ( \"'%s' (V02) \\n \" , s ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* reverse: reverse string s in place */ void reverse ( char s []) { int c , i , j ; for ( i = 0 , j = strlen ( s ) -1 ; i < j ; i ++ , j -- ) c = s [ i ], s [ i ] = s [ j ], s [ j ] = c ; } /* itoa_V01: convert n to characters in s */ void itoa_V01 ( int n , char s []) { int i , sign ; if (( sign = n ) < 0 ) /* record sign */ n = - n ; /* make n positive */ i = 0 ; do { /* generate digits in reverse order */ s [ i ++ ] = n % 10 + '0' ; /* get next digit */ } while (( n /= 10 ) > 0 ); /* delete it */ if ( sign < 0 ) s [ i ++ ] = '-' ; s [ i ] = '\\0' ; reverse ( s ); } /* itoa_V02: convert n to characters in s -> handles the largest negative number, that is, the value of n equal to -(2^(wordsize-1)) */ void itoa_V02 ( int n , char s []) { int i , sign ; if (( sign = n ) < 0 ) /* record sign */ n = - ( n + 1 ); /* make n positive (and add 1 to avoid overflow for INT_MIN)*/ i = 0 ; do { /* generate digits in reverse order */ s [ i ++ ] = n % 10 + '0' ; /* get next digit */ } while (( n /= 10 ) > 0 ); /* delete it */ if ( sign < 0 ) { s [ i ++ ] = '-' ; s [ 0 ] ++ ; /* 0th element is Incremented by 1 to compensate for the addition that we did above */ } s [ i ] = '\\0' ; reverse ( s ); } /* Reason itoa_V01 won't work for n = INT_MIN (-(2^(wordsize-1))) -------------------------------------------------------------------------------------------------------- INT_MIN = -2147483648; INT_MAX = 2147483647; so when we do n = -n, overflow occurs, because n cannot store 2147483648 (It can only store 2147483647) -------------------------------------------------------------------------------------------------------- */","title":"Exercise 3-4. In a two's complement number representation, our version of itoa does not handle the largest negative number, that is, the value of n equal to -(2^(wordsize-1)). Explain why not. Modify it to print that value correctly, regardless of the machine on which it runs."},{"location":"Chapter_03/EX3_05/","text":"Exercise 3-5. Write the function itob(n,s,b) that converts the integer n into a base b character representation in the string s. In particular, itob(n,s,16) formats s as a hexadecimal integer in s. /* Exercise 3-5. Write the function itob(n,s,b) that converts the integer n into a base b character representation in the string s. In particular, itob(n,s,16) formats s as a hexadecimal integer in s.*/ #include <stdio.h> #include <string.h> #define LIMIT 100 void reverse ( char s []); void itob ( int n , char s [], int b ); int main () { int n = 43981 ; int b = 16 ; char s [ LIMIT ]; itob ( n , s , b ); printf ( \"Integer %d converted to a base %d character representation is = %s \\n \" , n , b , s ); return 0 ; } /* reverse: reverse string s in place */ void reverse ( char s []) { int c , i , j ; for ( i = 0 , j = strlen ( s ) -1 ; i < j ; i ++ , j -- ) c = s [ i ], s [ i ] = s [ j ], s [ j ] = c ; } void itob ( int n , char s [], int b ) { int i , sign , x ; if (( sign = n ) < 0 ) /* record sign */ n = - ( n + 1 ); /* make n positive (and add 1 to avoid overflow for INT_MIN)*/ i = 0 ; do { /* generate digits in reverse order */ x = n % b + '0' ; /* get next digit */ x = ( x > 57 ) ? ( x + 7 ) : x ; /* Add 7 to make compatible for base > 10 */ s [ i ++ ] = x ; } while (( n /= b ) > 0 ); /* delete it */ if ( sign < 0 ) { s [ i ++ ] = '-' ; s [ 0 ] ++ ; /* 0th element is Incremented by 1 to compensate for the addition that we did above */ } s [ i ] = '\\0' ; reverse ( s ); }","title":"Example 5"},{"location":"Chapter_03/EX3_05/#exercise-3-5-write-the-function-itobnsb-that-converts-the-integer-n-into-a-base-b-character-representation-in-the-string-s-in-particular-itobns16-formats-s-as-a-hexadecimal-integer-in-s","text":"/* Exercise 3-5. Write the function itob(n,s,b) that converts the integer n into a base b character representation in the string s. In particular, itob(n,s,16) formats s as a hexadecimal integer in s.*/ #include <stdio.h> #include <string.h> #define LIMIT 100 void reverse ( char s []); void itob ( int n , char s [], int b ); int main () { int n = 43981 ; int b = 16 ; char s [ LIMIT ]; itob ( n , s , b ); printf ( \"Integer %d converted to a base %d character representation is = %s \\n \" , n , b , s ); return 0 ; } /* reverse: reverse string s in place */ void reverse ( char s []) { int c , i , j ; for ( i = 0 , j = strlen ( s ) -1 ; i < j ; i ++ , j -- ) c = s [ i ], s [ i ] = s [ j ], s [ j ] = c ; } void itob ( int n , char s [], int b ) { int i , sign , x ; if (( sign = n ) < 0 ) /* record sign */ n = - ( n + 1 ); /* make n positive (and add 1 to avoid overflow for INT_MIN)*/ i = 0 ; do { /* generate digits in reverse order */ x = n % b + '0' ; /* get next digit */ x = ( x > 57 ) ? ( x + 7 ) : x ; /* Add 7 to make compatible for base > 10 */ s [ i ++ ] = x ; } while (( n /= b ) > 0 ); /* delete it */ if ( sign < 0 ) { s [ i ++ ] = '-' ; s [ 0 ] ++ ; /* 0th element is Incremented by 1 to compensate for the addition that we did above */ } s [ i ] = '\\0' ; reverse ( s ); }","title":"Exercise 3-5. Write the function itob(n,s,b) that converts the integer n into a base b character representation in the string s. In particular, itob(n,s,16) formats s as a hexadecimal integer in s."},{"location":"Chapter_03/EX3_06/","text":"Exercise 3-6. Write a version of itoa that accepts three arguments instead of two. The third argument is a minimum field width; the converted number must be padded with blanks on the left if necessary to make it wide enough. /* Exercise 3-6. Write a version of itoa that accepts three arguments instead of two. The third argument is a minimum field width; the converted number must be padded with blanks on the left if necessary to make it wide enough.*/ #include <stdio.h> #include <string.h> #include <limits.h> #define LIMIT 100 #define VERSION 2 /* change the version number to either 1 or 2 */ void reverse ( char s []); void itoa_V01 ( int n , char s []); void itoa_V02 ( int n , char s [], int field_width ); int main () { int n = INT_MIN ; int field_width = 20 ; char s [ LIMIT ]; if ( VERSION == 1 ) { itoa_V01 ( n , s ); printf ( \"'%s' (V01) \\n \" , s ); } else if ( VERSION == 2 ) { itoa_V02 ( n , s , field_width ); printf ( \"'%s' (V02) \\n \" , s ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* reverse: reverse string s in place */ void reverse ( char s []) { int c , i , j ; for ( i = 0 , j = strlen ( s ) -1 ; i < j ; i ++ , j -- ) c = s [ i ], s [ i ] = s [ j ], s [ j ] = c ; } /* itoa_V01: convert n to characters in s */ void itoa_V01 ( int n , char s []) { int i , sign ; if (( sign = n ) < 0 ) /* record sign */ n = - ( n + 1 ); /* make n positive (and add 1 to avoid overflow for INT_MIN)*/ i = 0 ; do { /* generate digits in reverse order */ s [ i ++ ] = n % 10 + '0' ; /* get next digit */ } while (( n /= 10 ) > 0 ); /* delete it */ if ( sign < 0 ) { s [ i ++ ] = '-' ; s [ 0 ] ++ ; /* 0th element is Incremented by 1 to compensate for the addition that we did above */ } s [ i ] = '\\0' ; reverse ( s ); } /* itoa_V02: convert n to characters in s -> minimum field width is added as a third argument */ void itoa_V02 ( int n , char s [], int field_width ) { int i , sign ; if (( sign = n ) < 0 ) /* record sign */ n = - ( n + 1 ); /* make n positive (and add 1 to avoid overflow for INT_MIN)*/ i = 0 ; do { /* generate digits in reverse order */ s [ i ++ ] = n % 10 + '0' ; /* get next digit */ } while (( n /= 10 ) > 0 ); /* delete it */ if ( sign < 0 ) { s [ i ++ ] = '-' ; s [ 0 ] ++ ; /* 0th element is Incremented by 1 to compensate for the addition that we did above */ } while ( i < field_width ) s [ i ++ ] = 32 ; /* padded with blanks on the left to make it wide enough (i.e, field_width)*/ s [ i ] = '\\0' ; reverse ( s ); }","title":"Example 6"},{"location":"Chapter_03/EX3_06/#exercise-3-6-write-a-version-of-itoa-that-accepts-three-arguments-instead-of-two-the-third-argument-is-a-minimum-field-width-the-converted-number-must-be-padded-with-blanks-on-the-left-if-necessary-to-make-it-wide-enough","text":"/* Exercise 3-6. Write a version of itoa that accepts three arguments instead of two. The third argument is a minimum field width; the converted number must be padded with blanks on the left if necessary to make it wide enough.*/ #include <stdio.h> #include <string.h> #include <limits.h> #define LIMIT 100 #define VERSION 2 /* change the version number to either 1 or 2 */ void reverse ( char s []); void itoa_V01 ( int n , char s []); void itoa_V02 ( int n , char s [], int field_width ); int main () { int n = INT_MIN ; int field_width = 20 ; char s [ LIMIT ]; if ( VERSION == 1 ) { itoa_V01 ( n , s ); printf ( \"'%s' (V01) \\n \" , s ); } else if ( VERSION == 2 ) { itoa_V02 ( n , s , field_width ); printf ( \"'%s' (V02) \\n \" , s ); } else printf ( \"Entered version number is not correct \\n \" ); return 0 ; } /* reverse: reverse string s in place */ void reverse ( char s []) { int c , i , j ; for ( i = 0 , j = strlen ( s ) -1 ; i < j ; i ++ , j -- ) c = s [ i ], s [ i ] = s [ j ], s [ j ] = c ; } /* itoa_V01: convert n to characters in s */ void itoa_V01 ( int n , char s []) { int i , sign ; if (( sign = n ) < 0 ) /* record sign */ n = - ( n + 1 ); /* make n positive (and add 1 to avoid overflow for INT_MIN)*/ i = 0 ; do { /* generate digits in reverse order */ s [ i ++ ] = n % 10 + '0' ; /* get next digit */ } while (( n /= 10 ) > 0 ); /* delete it */ if ( sign < 0 ) { s [ i ++ ] = '-' ; s [ 0 ] ++ ; /* 0th element is Incremented by 1 to compensate for the addition that we did above */ } s [ i ] = '\\0' ; reverse ( s ); } /* itoa_V02: convert n to characters in s -> minimum field width is added as a third argument */ void itoa_V02 ( int n , char s [], int field_width ) { int i , sign ; if (( sign = n ) < 0 ) /* record sign */ n = - ( n + 1 ); /* make n positive (and add 1 to avoid overflow for INT_MIN)*/ i = 0 ; do { /* generate digits in reverse order */ s [ i ++ ] = n % 10 + '0' ; /* get next digit */ } while (( n /= 10 ) > 0 ); /* delete it */ if ( sign < 0 ) { s [ i ++ ] = '-' ; s [ 0 ] ++ ; /* 0th element is Incremented by 1 to compensate for the addition that we did above */ } while ( i < field_width ) s [ i ++ ] = 32 ; /* padded with blanks on the left to make it wide enough (i.e, field_width)*/ s [ i ] = '\\0' ; reverse ( s ); }","title":"Exercise 3-6. Write a version of itoa that accepts three arguments instead of two. The third argument is a minimum field width; the converted number must be padded with blanks on the left if necessary to make it wide enough."},{"location":"Chapter_04/EX4_01/","text":"Exercise 4-1. Write the function strindex(s,t) which returns the position of the rightmost occurrence of t in s, or -1 if there is none. /* Exercise 4-1. Write the function strindex(s,t) which returns the position of the rightmost occurrence of t in s, or -1 if there is none. */ #include <stdio.h> #include <string.h> #define MAXLINE 1000 /* maximum input line length */ int getsline ( char line [], int max ); int strindex ( char source [], char searchfor []); char pattern [] = \"bc\" ; /* pattern to search for */ /* find all lines matching pattern */ int main () { char line [ MAXLINE ]; int found = 0 ; int pos = 0 ; while ( getsline ( line , MAXLINE ) > 0 ) { pos = strindex ( line , pattern ); if ( pos >= 0 ) { printf ( \"Rightmost occurene of %s in %s is = %d \\n \" , pattern , line , pos ); found ++ ; } else printf ( \"Match pattern not found ! \\n \" ); } return found ; } /* getsline: get line into s, return length */ int getsline ( char s [], int lim ) { int c , i ; i = 0 ; while ( -- lim > 0 && ( c = getchar ()) != EOF && c != '\\n' ) s [ i ++ ] = c ; if ( c == '\\n' ) s [ i ++ ] = c ; s [ i ] = '\\0' ; return i ; } /* strindex: return position of the rightmost occurrence of t in s, -1 if none */ int strindex ( char s [], char t []) { int i , j , k ; for ( i = strlen ( s ) - 1 ; i >= 0 ; i -- ) { for ( j = i , k = 0 ; t [ k ] != '\\0' && s [ j ] == t [ k ]; j ++ , k ++ ) ; if ( k > 0 && t [ k ] == '\\0' ) return i ; } return -1 ; }","title":"Example 1"},{"location":"Chapter_04/EX4_01/#exercise-4-1-write-the-function-strindexst-which-returns-the-position-of-the-rightmost-occurrence-of-t-in-s-or-1-if-there-is-none","text":"/* Exercise 4-1. Write the function strindex(s,t) which returns the position of the rightmost occurrence of t in s, or -1 if there is none. */ #include <stdio.h> #include <string.h> #define MAXLINE 1000 /* maximum input line length */ int getsline ( char line [], int max ); int strindex ( char source [], char searchfor []); char pattern [] = \"bc\" ; /* pattern to search for */ /* find all lines matching pattern */ int main () { char line [ MAXLINE ]; int found = 0 ; int pos = 0 ; while ( getsline ( line , MAXLINE ) > 0 ) { pos = strindex ( line , pattern ); if ( pos >= 0 ) { printf ( \"Rightmost occurene of %s in %s is = %d \\n \" , pattern , line , pos ); found ++ ; } else printf ( \"Match pattern not found ! \\n \" ); } return found ; } /* getsline: get line into s, return length */ int getsline ( char s [], int lim ) { int c , i ; i = 0 ; while ( -- lim > 0 && ( c = getchar ()) != EOF && c != '\\n' ) s [ i ++ ] = c ; if ( c == '\\n' ) s [ i ++ ] = c ; s [ i ] = '\\0' ; return i ; } /* strindex: return position of the rightmost occurrence of t in s, -1 if none */ int strindex ( char s [], char t []) { int i , j , k ; for ( i = strlen ( s ) - 1 ; i >= 0 ; i -- ) { for ( j = i , k = 0 ; t [ k ] != '\\0' && s [ j ] == t [ k ]; j ++ , k ++ ) ; if ( k > 0 && t [ k ] == '\\0' ) return i ; } return -1 ; }","title":"Exercise 4-1. Write the function strindex(s,t) which returns the position of the rightmost occurrence of t in s, or -1 if there is none."},{"location":"Chapter_04/EX4_02/","text":"Exercise 4-2. Extend atof to handle scientific notation of the form 123.45e-6 where a floating-point number may be followed by e or E and an optionally signed exponent. /* Exercise 4-2. Extend atof to handle scientific notation of the form 123.45e-6 where a floating-point number may be followed by e or E and an optionally signed exponent. */ #include <stdio.h> #include <ctype.h> #include <math.h> #define MAXLINE 1000 /* maximum input line length */ double atof ( char s []); int main () { char s [ MAXLINE ] = \"-123.45e-1\" ; double f = 0.0 ; f = atof ( s ); printf ( \"String %s converted to float is = %g \\n \" , s , f ); return 0 ; } /* atof: convert string s to double */ double atof ( char s []) { double val , power , exp ; int i , sign , exp_sign ; for ( i = 0 ; isspace ( s [ i ]); i ++ ) /* skip white space */ ; sign = ( s [ i ] == '-' ) ? -1 : 1 ; if ( s [ i ] == '+' || s [ i ] == '-' ) i ++ ; for ( val = 0.0 ; isdigit ( s [ i ]); i ++ ) val = 10.0 * val + ( s [ i ] - '0' ); if ( s [ i ] == '.' ) i ++ ; for ( power = 1.0 ; isdigit ( s [ i ]); i ++ ) { val = 10.0 * val + ( s [ i ] - '0' ); power *= 10 ; } if ( s [ i ] == 'e' || s [ i ] == 'E' ) i ++ ; exp_sign = ( s [ i ] == '-' ) ? -1 : 1 ; if ( s [ i ] == '+' || s [ i ] == '-' ) i ++ ; for ( exp = 0.0 ; isdigit ( s [ i ]); i ++ ) { exp = 10.0 * exp + ( s [ i ] - '0' ); } exp = pow ( 10.0 , ( exp_sign * exp )); return (( sign * val / power ) * ( exp )); } /* ERROR : ----- $ gcc EX4_02.c /usr/bin/ld: /tmp/cci7hVKf.o: in function `atof': EX4_02.c:(.text+0x2fb): undefined reference to `pow' collect2: error: ld returned 1 exit status SOLUTION : -------- The error you are seeing: error: ld returned 1 exit status is from the linker ld (part of gcc that combines the object files) because it is unable to find where the function pow is defined. Including math.h brings in the declaration of the various functions and not their definition. The def is present in the math library libm.a. You need to link your program with this library so that the calls to functions like pow() are resolved. gcc EX4_02.c -lm SOURCE : ------ https://stackoverflow.com/a/12824148 */","title":"Example 2"},{"location":"Chapter_04/EX4_02/#exercise-4-2-extend-atof-to-handle-scientific-notation-of-the-form-12345e-6-where-a-floating-point-number-may-be-followed-by-e-or-e-and-an-optionally-signed-exponent","text":"/* Exercise 4-2. Extend atof to handle scientific notation of the form 123.45e-6 where a floating-point number may be followed by e or E and an optionally signed exponent. */ #include <stdio.h> #include <ctype.h> #include <math.h> #define MAXLINE 1000 /* maximum input line length */ double atof ( char s []); int main () { char s [ MAXLINE ] = \"-123.45e-1\" ; double f = 0.0 ; f = atof ( s ); printf ( \"String %s converted to float is = %g \\n \" , s , f ); return 0 ; } /* atof: convert string s to double */ double atof ( char s []) { double val , power , exp ; int i , sign , exp_sign ; for ( i = 0 ; isspace ( s [ i ]); i ++ ) /* skip white space */ ; sign = ( s [ i ] == '-' ) ? -1 : 1 ; if ( s [ i ] == '+' || s [ i ] == '-' ) i ++ ; for ( val = 0.0 ; isdigit ( s [ i ]); i ++ ) val = 10.0 * val + ( s [ i ] - '0' ); if ( s [ i ] == '.' ) i ++ ; for ( power = 1.0 ; isdigit ( s [ i ]); i ++ ) { val = 10.0 * val + ( s [ i ] - '0' ); power *= 10 ; } if ( s [ i ] == 'e' || s [ i ] == 'E' ) i ++ ; exp_sign = ( s [ i ] == '-' ) ? -1 : 1 ; if ( s [ i ] == '+' || s [ i ] == '-' ) i ++ ; for ( exp = 0.0 ; isdigit ( s [ i ]); i ++ ) { exp = 10.0 * exp + ( s [ i ] - '0' ); } exp = pow ( 10.0 , ( exp_sign * exp )); return (( sign * val / power ) * ( exp )); } /* ERROR : ----- $ gcc EX4_02.c /usr/bin/ld: /tmp/cci7hVKf.o: in function `atof': EX4_02.c:(.text+0x2fb): undefined reference to `pow' collect2: error: ld returned 1 exit status SOLUTION : -------- The error you are seeing: error: ld returned 1 exit status is from the linker ld (part of gcc that combines the object files) because it is unable to find where the function pow is defined. Including math.h brings in the declaration of the various functions and not their definition. The def is present in the math library libm.a. You need to link your program with this library so that the calls to functions like pow() are resolved. gcc EX4_02.c -lm SOURCE : ------ https://stackoverflow.com/a/12824148 */","title":"Exercise 4-2. Extend atof to handle scientific notation of the form 123.45e-6 where a floating-point number may be followed by e or E and an optionally signed exponent."},{"location":"Chapter_04/EX4_03/","text":"Exercise 4-3. Given the basic framework, it's straightforward to extend the calculator. Add the modulus (%) operator and provisions for negative numbers. /* Exercise 4-3. Given the basic framework, it's straightforward to extend the calculator. Add the modulus (%) operator and provisions for negative numbers. */ #include <stdio.h> #include <stdlib.h> /* for atof() */ #define MAXOP 100 /* max size of operand or operator */ #define NUMBER '0' /* signal that a number was found */ int getop ( char []); void push ( double ); double pop ( void ); /* reverse Polish calculator */ int main () { int type ; double op2 ; char s [ MAXOP ]; while (( type = getop ( s )) != EOF ) { switch ( type ) { case NUMBER : push ( atof ( s )); break ; case '+' : push ( pop () + pop ()); break ; case '*' : push ( pop () * pop ()); break ; case '-' : op2 = pop (); push ( pop () - op2 ); break ; case '/' : op2 = pop (); if ( op2 != 0.0 ) push ( pop () / op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '%' : op2 = pop (); if ( op2 != 0.0 ) push (( int ) pop () % ( int ) op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '\\n' : printf ( \" \\t %.8g \\n \" , pop ()); break ; default : printf ( \"error: unknown command %s \\n \" , s ); break ; } } return 0 ; } #define MAXVAL 100 /* maximum depth of val stack */ int sp = 0 ; /* next free stack position */ double val [ MAXVAL ]; /* value stack */ /* push: push f onto value stack */ void push ( double f ) { if ( sp < MAXVAL ) val [ sp ++ ] = f ; else printf ( \"error: stack full, can't push %g \\n \" , f ); } /* pop: pop and return top value from stack */ double pop ( void ) { if ( sp > 0 ) return val [ -- sp ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } #include <ctype.h> int getch ( void ); void ungetch ( int ); /* getop: get next character or numeric operand */ int getop ( char s []) { int i , c ; while (( s [ 0 ] = c = getch ()) == ' ' || c == '\\t' ) ; s [ 1 ] = '\\0' ; if ( ! isdigit ( c ) && c != '.' ) return c ; /* not a number */ i = 0 ; if ( isdigit ( c )) /* collect integer part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; if ( c == '.' ) /* collect fraction part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; s [ i ] = '\\0' ; if ( c != EOF ) ungetch ( c ); return NUMBER ; } #define BUFSIZE 100 char buf [ BUFSIZE ]; /* buffer for ungetch */ int bufp = 0 ; /* next free position in buf */ int getch ( void ) /* get a (possibly pushed-back) character */ { return ( bufp > 0 ) ? buf [ -- bufp ] : getchar (); } void ungetch ( int c ) /* push character back on input */ { if ( bufp >= BUFSIZE ) printf ( \"ungetch: too many characters \\n \" ); else buf [ bufp ++ ] = c ; }","title":"Example 3"},{"location":"Chapter_04/EX4_03/#exercise-4-3-given-the-basic-framework-its-straightforward-to-extend-the-calculator-add-the-modulus-operator-and-provisions-for-negative-numbers","text":"/* Exercise 4-3. Given the basic framework, it's straightforward to extend the calculator. Add the modulus (%) operator and provisions for negative numbers. */ #include <stdio.h> #include <stdlib.h> /* for atof() */ #define MAXOP 100 /* max size of operand or operator */ #define NUMBER '0' /* signal that a number was found */ int getop ( char []); void push ( double ); double pop ( void ); /* reverse Polish calculator */ int main () { int type ; double op2 ; char s [ MAXOP ]; while (( type = getop ( s )) != EOF ) { switch ( type ) { case NUMBER : push ( atof ( s )); break ; case '+' : push ( pop () + pop ()); break ; case '*' : push ( pop () * pop ()); break ; case '-' : op2 = pop (); push ( pop () - op2 ); break ; case '/' : op2 = pop (); if ( op2 != 0.0 ) push ( pop () / op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '%' : op2 = pop (); if ( op2 != 0.0 ) push (( int ) pop () % ( int ) op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '\\n' : printf ( \" \\t %.8g \\n \" , pop ()); break ; default : printf ( \"error: unknown command %s \\n \" , s ); break ; } } return 0 ; } #define MAXVAL 100 /* maximum depth of val stack */ int sp = 0 ; /* next free stack position */ double val [ MAXVAL ]; /* value stack */ /* push: push f onto value stack */ void push ( double f ) { if ( sp < MAXVAL ) val [ sp ++ ] = f ; else printf ( \"error: stack full, can't push %g \\n \" , f ); } /* pop: pop and return top value from stack */ double pop ( void ) { if ( sp > 0 ) return val [ -- sp ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } #include <ctype.h> int getch ( void ); void ungetch ( int ); /* getop: get next character or numeric operand */ int getop ( char s []) { int i , c ; while (( s [ 0 ] = c = getch ()) == ' ' || c == '\\t' ) ; s [ 1 ] = '\\0' ; if ( ! isdigit ( c ) && c != '.' ) return c ; /* not a number */ i = 0 ; if ( isdigit ( c )) /* collect integer part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; if ( c == '.' ) /* collect fraction part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; s [ i ] = '\\0' ; if ( c != EOF ) ungetch ( c ); return NUMBER ; } #define BUFSIZE 100 char buf [ BUFSIZE ]; /* buffer for ungetch */ int bufp = 0 ; /* next free position in buf */ int getch ( void ) /* get a (possibly pushed-back) character */ { return ( bufp > 0 ) ? buf [ -- bufp ] : getchar (); } void ungetch ( int c ) /* push character back on input */ { if ( bufp >= BUFSIZE ) printf ( \"ungetch: too many characters \\n \" ); else buf [ bufp ++ ] = c ; }","title":"Exercise 4-3. Given the basic framework, it's straightforward to extend the calculator. Add the modulus (%) operator and provisions for negative numbers."},{"location":"Chapter_04/EX4_04/","text":"Exercise 4-4. Add the commands to print the top element of the stack without popping, to duplicate it, and to swap the top two elements. Add a command to clear the stack. /* Exercise 4-4. Add the commands to print the top element of the stack without popping, to duplicate it, and to swap the top two elements. Add a command to clear the stack. */ #include <stdio.h> #include <stdlib.h> /* for atof() */ #define MAXOP 100 /* max size of operand or operator */ #define NUMBER '0' /* signal that a number was found */ int getop ( char []); void push ( double ); double pop ( void ); double top ( void ); void duplicate_top ( void ); void swap_top2 ( void ); void clear ( void ); void view_stack ( void ); /* reverse Polish calculator */ int main () { int type ; double op2 ; char s [ MAXOP ]; while (( type = getop ( s )) != EOF ) { switch ( type ) { case NUMBER : push ( atof ( s )); break ; case '+' : push ( pop () + pop ()); break ; case '*' : push ( pop () * pop ()); break ; case '-' : op2 = pop (); push ( pop () - op2 ); break ; case '/' : op2 = pop (); if ( op2 != 0.0 ) push ( pop () / op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '%' : op2 = pop (); if ( op2 != 0.0 ) push (( int ) pop () % ( int ) op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '\\n' : printf ( \" \\t %.8g \\n \" , pop ()); break ; case 't' : printf ( \"Top element in a stack = %g \\n \" , top ()); break ; case 'v' : view_stack (); break ; case 's' : swap_top2 (); break ; case 'd' : duplicate_top (); break ; case 'c' : clear (); break ; default : printf ( \"error: unknown command %s \\n \" , s ); break ; } } return 0 ; } #define MAXVAL 100 /* maximum depth of val stack */ int sp = 0 ; /* next free stack position */ double val [ MAXVAL ]; /* value stack */ /* push: push f onto value stack */ void push ( double f ) { if ( sp < MAXVAL ) val [ sp ++ ] = f ; else printf ( \"error: stack full, can't push %g \\n \" , f ); } /* pop: pop and return top value from stack */ double pop ( void ) { if ( sp > 0 ) return val [ -- sp ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } /* print the top element of the stack without popping */ double top ( void ) { if ( sp > 0 ) return val [ sp - 1 ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } /* duplicate the top element of the stack */ void duplicate_top ( void ) { if ( sp > 0 ) { val [ sp ] = val [ sp - 1 ]; sp ++ ; } else printf ( \"error: stack empty \\n \" ); } /* swap the top two elements of the stack*/ void swap_top2 ( void ) { double tmp ; if ( sp > 1 ) { tmp = val [ sp - 2 ]; val [ sp - 2 ] = val [ sp - 1 ]; val [ sp - 1 ] = tmp ; } else printf ( \"error: stack contains less than 2 elements \\n \" ); } /* clear the stack*/ void clear ( void ) { sp = ( sp > 0 ) ? 0 : sp ; } /* print stack elements */ void view_stack ( void ) { int vp = sp ; while ( -- vp >= 0 ) printf ( \"%g \\n \" , val [ vp ]); } #include <ctype.h> int getch ( void ); void ungetch ( int ); /* getop: get next character or numeric operand */ int getop ( char s []) { int i , c ; while (( s [ 0 ] = c = getch ()) == ' ' || c == '\\t' ) ; s [ 1 ] = '\\0' ; if ( ! isdigit ( c ) && c != '.' ) return c ; /* not a number */ i = 0 ; if ( isdigit ( c )) /* collect integer part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; if ( c == '.' ) /* collect fraction part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; s [ i ] = '\\0' ; if ( c != EOF ) ungetch ( c ); return NUMBER ; } #define BUFSIZE 100 char buf [ BUFSIZE ]; /* buffer for ungetch */ int bufp = 0 ; /* next free position in buf */ int getch ( void ) /* get a (possibly pushed-back) character */ { return ( bufp > 0 ) ? buf [ -- bufp ] : getchar (); } void ungetch ( int c ) /* push character back on input */ { if ( bufp >= BUFSIZE ) printf ( \"ungetch: too many characters \\n \" ); else buf [ bufp ++ ] = c ; }","title":"Example 4"},{"location":"Chapter_04/EX4_04/#exercise-4-4-add-the-commands-to-print-the-top-element-of-the-stack-without-popping-to-duplicate-it-and-to-swap-the-top-two-elements-add-a-command-to-clear-the-stack","text":"/* Exercise 4-4. Add the commands to print the top element of the stack without popping, to duplicate it, and to swap the top two elements. Add a command to clear the stack. */ #include <stdio.h> #include <stdlib.h> /* for atof() */ #define MAXOP 100 /* max size of operand or operator */ #define NUMBER '0' /* signal that a number was found */ int getop ( char []); void push ( double ); double pop ( void ); double top ( void ); void duplicate_top ( void ); void swap_top2 ( void ); void clear ( void ); void view_stack ( void ); /* reverse Polish calculator */ int main () { int type ; double op2 ; char s [ MAXOP ]; while (( type = getop ( s )) != EOF ) { switch ( type ) { case NUMBER : push ( atof ( s )); break ; case '+' : push ( pop () + pop ()); break ; case '*' : push ( pop () * pop ()); break ; case '-' : op2 = pop (); push ( pop () - op2 ); break ; case '/' : op2 = pop (); if ( op2 != 0.0 ) push ( pop () / op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '%' : op2 = pop (); if ( op2 != 0.0 ) push (( int ) pop () % ( int ) op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '\\n' : printf ( \" \\t %.8g \\n \" , pop ()); break ; case 't' : printf ( \"Top element in a stack = %g \\n \" , top ()); break ; case 'v' : view_stack (); break ; case 's' : swap_top2 (); break ; case 'd' : duplicate_top (); break ; case 'c' : clear (); break ; default : printf ( \"error: unknown command %s \\n \" , s ); break ; } } return 0 ; } #define MAXVAL 100 /* maximum depth of val stack */ int sp = 0 ; /* next free stack position */ double val [ MAXVAL ]; /* value stack */ /* push: push f onto value stack */ void push ( double f ) { if ( sp < MAXVAL ) val [ sp ++ ] = f ; else printf ( \"error: stack full, can't push %g \\n \" , f ); } /* pop: pop and return top value from stack */ double pop ( void ) { if ( sp > 0 ) return val [ -- sp ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } /* print the top element of the stack without popping */ double top ( void ) { if ( sp > 0 ) return val [ sp - 1 ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } /* duplicate the top element of the stack */ void duplicate_top ( void ) { if ( sp > 0 ) { val [ sp ] = val [ sp - 1 ]; sp ++ ; } else printf ( \"error: stack empty \\n \" ); } /* swap the top two elements of the stack*/ void swap_top2 ( void ) { double tmp ; if ( sp > 1 ) { tmp = val [ sp - 2 ]; val [ sp - 2 ] = val [ sp - 1 ]; val [ sp - 1 ] = tmp ; } else printf ( \"error: stack contains less than 2 elements \\n \" ); } /* clear the stack*/ void clear ( void ) { sp = ( sp > 0 ) ? 0 : sp ; } /* print stack elements */ void view_stack ( void ) { int vp = sp ; while ( -- vp >= 0 ) printf ( \"%g \\n \" , val [ vp ]); } #include <ctype.h> int getch ( void ); void ungetch ( int ); /* getop: get next character or numeric operand */ int getop ( char s []) { int i , c ; while (( s [ 0 ] = c = getch ()) == ' ' || c == '\\t' ) ; s [ 1 ] = '\\0' ; if ( ! isdigit ( c ) && c != '.' ) return c ; /* not a number */ i = 0 ; if ( isdigit ( c )) /* collect integer part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; if ( c == '.' ) /* collect fraction part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; s [ i ] = '\\0' ; if ( c != EOF ) ungetch ( c ); return NUMBER ; } #define BUFSIZE 100 char buf [ BUFSIZE ]; /* buffer for ungetch */ int bufp = 0 ; /* next free position in buf */ int getch ( void ) /* get a (possibly pushed-back) character */ { return ( bufp > 0 ) ? buf [ -- bufp ] : getchar (); } void ungetch ( int c ) /* push character back on input */ { if ( bufp >= BUFSIZE ) printf ( \"ungetch: too many characters \\n \" ); else buf [ bufp ++ ] = c ; }","title":"Exercise 4-4. Add the commands to print the top element of the stack without popping, to duplicate it, and to swap the top two elements. Add a command to clear the stack."},{"location":"Chapter_04/EX4_05/","text":"Exercise 4-5. Add access to library functions like sin, exp, and pow. See in Appendix B, Section 4. /* Exercise 4-5. Add access to library functions like sin, exp, and pow. See <math.h> in Appendix B, Section 4. */ #include <stdio.h> #include <stdlib.h> /* for atof() */ #include <string.h> /* for strcmp() */ #include <math.h> /* for sin, exp, pow */ #define MAXOP 100 /* max size of operand or operator */ #define NUMBER '0' /* signal that a number was found */ #define FUNCTION '1' /* signal that a function was found */ int getop ( char []); void push ( double ); double pop ( void ); double top ( void ); void duplicate_top ( void ); void swap_top2 ( void ); void clear ( void ); void view_stack ( void ); double math_func ( char []); /* reverse Polish calculator */ int main () { int type ; double op2 ; char s [ MAXOP ]; while (( type = getop ( s )) != EOF ) { switch ( type ) { case NUMBER : push ( atof ( s )); break ; case '+' : push ( pop () + pop ()); break ; case '*' : push ( pop () * pop ()); break ; case '-' : op2 = pop (); push ( pop () - op2 ); break ; case '/' : op2 = pop (); if ( op2 != 0.0 ) push ( pop () / op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '%' : op2 = pop (); if ( op2 != 0.0 ) push (( int ) pop () % ( int ) op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '\\n' : printf ( \" \\t %.8g \\n \" , pop ()); break ; /* case 't': printf(\"Top element in a stack = %g\\n\", top()); break; case 'v': view_stack(); break; case 's': swap_top2(); break; case 'd': duplicate_top(); break; case 'c': clear(); break; */ case FUNCTION : push ( math_func ( s )); break ; default : printf ( \"error: unknown command %s \\n \" , s ); break ; } } return 0 ; } #define MAXVAL 100 /* maximum depth of val stack */ int sp = 0 ; /* next free stack position */ double val [ MAXVAL ]; /* value stack */ /* push: push f onto value stack */ void push ( double f ) { if ( sp < MAXVAL ) val [ sp ++ ] = f ; else printf ( \"error: stack full, can't push %g \\n \" , f ); } /* pop: pop and return top value from stack */ double pop ( void ) { if ( sp > 0 ) return val [ -- sp ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } /* print the top element of the stack without popping */ double top ( void ) { if ( sp > 0 ) return val [ sp - 1 ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } /* duplicate the top element of the stack */ void duplicate_top ( void ) { if ( sp > 0 ) { val [ sp ] = val [ sp - 1 ]; sp ++ ; } else printf ( \"error: stack empty \\n \" ); } /* swap the top two elements of the stack*/ void swap_top2 ( void ) { double tmp ; if ( sp > 1 ) { tmp = val [ sp - 2 ]; val [ sp - 2 ] = val [ sp - 1 ]; val [ sp - 1 ] = tmp ; } else printf ( \"error: stack contains less than 2 elements \\n \" ); } /* clear the stack*/ void clear ( void ) { sp = ( sp > 0 ) ? 0 : sp ; } /* print stack elements */ void view_stack ( void ) { int vp = sp ; while ( -- vp >= 0 ) printf ( \"%g \\n \" , val [ vp ]); } /* Access to math functions available in math.h */ double math_func ( char s []) { if ( strcmp ( s , \"sin\" ) == 0 ) return ( sin ( pop ())); else { printf ( \"error: Function not in math.h \\n \" ); return 0.0 ; } } #include <ctype.h> int getch ( void ); void ungetch ( int ); /* getop: get next character or numeric operand */ int getop ( char s []) { int i , c ; while (( s [ 0 ] = c = getch ()) == ' ' || c == '\\t' ) ; s [ 1 ] = '\\0' ; if ( ! isdigit ( c ) && c != '.' ) return c ; /* not a number */ i = 0 ; if ( isdigit ( c )) /* collect integer part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; if ( c == '.' ) /* collect fraction part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; s [ i ] = '\\0' ; if ( c != EOF ) ungetch ( c ); return NUMBER ; } #define BUFSIZE 100 char buf [ BUFSIZE ]; /* buffer for ungetch */ int bufp = 0 ; /* next free position in buf */ int getch ( void ) /* get a (possibly pushed-back) character */ { return ( bufp > 0 ) ? buf [ -- bufp ] : getchar (); } void ungetch ( int c ) /* push character back on input */ { if ( bufp >= BUFSIZE ) printf ( \"ungetch: too many characters \\n \" ); else buf [ bufp ++ ] = c ; } /* ERROR : ----- $ gcc EX4_05.c /usr/bin/ld: /tmp/cc82gGCH.o: in function `main': EX4_05.c:(.text+0x1bd): undefined reference to `sin' collect2: error: ld returned 1 exit status SOLUTION : -------- The error you are seeing: error: ld returned 1 exit status is from the linker ld (part of gcc that combines the object files) because it is unable to find where the function pow is defined. Including math.h brings in the declaration of the various functions and not their definition. The def is present in the math library libm.a. You need to link your program with this library so that the calls to functions like pow() are resolved. $ gcc EX4_05.c -lm SOURCE : ------ https://stackoverflow.com/a/12824148 */","title":"Example 5"},{"location":"Chapter_04/EX4_05/#exercise-4-5-add-access-to-library-functions-like-sin-exp-and-pow-see-in-appendix-b-section-4","text":"/* Exercise 4-5. Add access to library functions like sin, exp, and pow. See <math.h> in Appendix B, Section 4. */ #include <stdio.h> #include <stdlib.h> /* for atof() */ #include <string.h> /* for strcmp() */ #include <math.h> /* for sin, exp, pow */ #define MAXOP 100 /* max size of operand or operator */ #define NUMBER '0' /* signal that a number was found */ #define FUNCTION '1' /* signal that a function was found */ int getop ( char []); void push ( double ); double pop ( void ); double top ( void ); void duplicate_top ( void ); void swap_top2 ( void ); void clear ( void ); void view_stack ( void ); double math_func ( char []); /* reverse Polish calculator */ int main () { int type ; double op2 ; char s [ MAXOP ]; while (( type = getop ( s )) != EOF ) { switch ( type ) { case NUMBER : push ( atof ( s )); break ; case '+' : push ( pop () + pop ()); break ; case '*' : push ( pop () * pop ()); break ; case '-' : op2 = pop (); push ( pop () - op2 ); break ; case '/' : op2 = pop (); if ( op2 != 0.0 ) push ( pop () / op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '%' : op2 = pop (); if ( op2 != 0.0 ) push (( int ) pop () % ( int ) op2 ); else printf ( \"error: zero divisor \\n \" ); break ; case '\\n' : printf ( \" \\t %.8g \\n \" , pop ()); break ; /* case 't': printf(\"Top element in a stack = %g\\n\", top()); break; case 'v': view_stack(); break; case 's': swap_top2(); break; case 'd': duplicate_top(); break; case 'c': clear(); break; */ case FUNCTION : push ( math_func ( s )); break ; default : printf ( \"error: unknown command %s \\n \" , s ); break ; } } return 0 ; } #define MAXVAL 100 /* maximum depth of val stack */ int sp = 0 ; /* next free stack position */ double val [ MAXVAL ]; /* value stack */ /* push: push f onto value stack */ void push ( double f ) { if ( sp < MAXVAL ) val [ sp ++ ] = f ; else printf ( \"error: stack full, can't push %g \\n \" , f ); } /* pop: pop and return top value from stack */ double pop ( void ) { if ( sp > 0 ) return val [ -- sp ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } /* print the top element of the stack without popping */ double top ( void ) { if ( sp > 0 ) return val [ sp - 1 ]; else { printf ( \"error: stack empty \\n \" ); return 0.0 ; } } /* duplicate the top element of the stack */ void duplicate_top ( void ) { if ( sp > 0 ) { val [ sp ] = val [ sp - 1 ]; sp ++ ; } else printf ( \"error: stack empty \\n \" ); } /* swap the top two elements of the stack*/ void swap_top2 ( void ) { double tmp ; if ( sp > 1 ) { tmp = val [ sp - 2 ]; val [ sp - 2 ] = val [ sp - 1 ]; val [ sp - 1 ] = tmp ; } else printf ( \"error: stack contains less than 2 elements \\n \" ); } /* clear the stack*/ void clear ( void ) { sp = ( sp > 0 ) ? 0 : sp ; } /* print stack elements */ void view_stack ( void ) { int vp = sp ; while ( -- vp >= 0 ) printf ( \"%g \\n \" , val [ vp ]); } /* Access to math functions available in math.h */ double math_func ( char s []) { if ( strcmp ( s , \"sin\" ) == 0 ) return ( sin ( pop ())); else { printf ( \"error: Function not in math.h \\n \" ); return 0.0 ; } } #include <ctype.h> int getch ( void ); void ungetch ( int ); /* getop: get next character or numeric operand */ int getop ( char s []) { int i , c ; while (( s [ 0 ] = c = getch ()) == ' ' || c == '\\t' ) ; s [ 1 ] = '\\0' ; if ( ! isdigit ( c ) && c != '.' ) return c ; /* not a number */ i = 0 ; if ( isdigit ( c )) /* collect integer part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; if ( c == '.' ) /* collect fraction part */ while ( isdigit ( s [ ++ i ] = c = getch ())) ; s [ i ] = '\\0' ; if ( c != EOF ) ungetch ( c ); return NUMBER ; } #define BUFSIZE 100 char buf [ BUFSIZE ]; /* buffer for ungetch */ int bufp = 0 ; /* next free position in buf */ int getch ( void ) /* get a (possibly pushed-back) character */ { return ( bufp > 0 ) ? buf [ -- bufp ] : getchar (); } void ungetch ( int c ) /* push character back on input */ { if ( bufp >= BUFSIZE ) printf ( \"ungetch: too many characters \\n \" ); else buf [ bufp ++ ] = c ; } /* ERROR : ----- $ gcc EX4_05.c /usr/bin/ld: /tmp/cc82gGCH.o: in function `main': EX4_05.c:(.text+0x1bd): undefined reference to `sin' collect2: error: ld returned 1 exit status SOLUTION : -------- The error you are seeing: error: ld returned 1 exit status is from the linker ld (part of gcc that combines the object files) because it is unable to find where the function pow is defined. Including math.h brings in the declaration of the various functions and not their definition. The def is present in the math library libm.a. You need to link your program with this library so that the calls to functions like pow() are resolved. $ gcc EX4_05.c -lm SOURCE : ------ https://stackoverflow.com/a/12824148 */","title":"Exercise 4-5. Add access to library functions like sin, exp, and pow. See  in Appendix B, Section 4."},{"location":"Chapter_05/EX5_01/","text":"Exercise 5-1. As written, getint treats a + or - not followed by a digit as a valid representation of zero. Fix it to push such a character back on the input. /* Exercise 5-1. As written, getint treats a + or - not followed by a digit as a valid representation of zero. Fix it to push such a character back on the input. */ #include <stdio.h> #include <ctype.h> #define SIZE 5 int getint ( int * pn ); int main () { int n , a , array [ SIZE ]; for ( n = 0 ; n < SIZE && ( a = getint ( & array [ n ])) != EOF ; n ++ ) printf ( \"array[%d] = %d, a = %d \\n \" , n , array [ n ], a ); return 0 ; } int getch ( void ); void ungetch ( int ); /* getint: get next integer from input into *pn */ int getint ( int * pn ) { int c , sign ; while ( isspace ( c = getch ())) /* skip white space */ ; if ( ! isdigit ( c ) && c != EOF && c != '+' && c != '-' ) { ungetch ( c ); /* it is not a number */ return 0 ; } sign = ( c == '-' ) ? -1 : 1 ; if ( c == '+' || c == '-' ) { c = getch (); if ( ! isdigit ( c )) { ungetch ( c ); /* it is not a number */ return 0 ; } } for ( * pn = 0 ; isdigit ( c ); c = getch ()) * pn = 10 * * pn + ( c - '0' ); * pn *= sign ; if ( c != EOF ) ungetch ( c ); return c ; } #define BUFSIZE 100 char buf [ BUFSIZE ]; /* buffer for ungetch */ int bufp = 0 ; /* next free position in buf */ int getch ( void ) /* get a (possibly pushed-back) character */ { return ( bufp > 0 ) ? buf [ -- bufp ] : getchar (); } void ungetch ( int c ) /* push character back on input */ { if ( bufp >= BUFSIZE ) printf ( \"ungetch: too many characters \\n \" ); else buf [ bufp ++ ] = c ; }","title":"Example 1"},{"location":"Chapter_05/EX5_01/#exercise-5-1-as-written-getint-treats-a-or-not-followed-by-a-digit-as-a-valid-representation-of-zero-fix-it-to-push-such-a-character-back-on-the-input","text":"/* Exercise 5-1. As written, getint treats a + or - not followed by a digit as a valid representation of zero. Fix it to push such a character back on the input. */ #include <stdio.h> #include <ctype.h> #define SIZE 5 int getint ( int * pn ); int main () { int n , a , array [ SIZE ]; for ( n = 0 ; n < SIZE && ( a = getint ( & array [ n ])) != EOF ; n ++ ) printf ( \"array[%d] = %d, a = %d \\n \" , n , array [ n ], a ); return 0 ; } int getch ( void ); void ungetch ( int ); /* getint: get next integer from input into *pn */ int getint ( int * pn ) { int c , sign ; while ( isspace ( c = getch ())) /* skip white space */ ; if ( ! isdigit ( c ) && c != EOF && c != '+' && c != '-' ) { ungetch ( c ); /* it is not a number */ return 0 ; } sign = ( c == '-' ) ? -1 : 1 ; if ( c == '+' || c == '-' ) { c = getch (); if ( ! isdigit ( c )) { ungetch ( c ); /* it is not a number */ return 0 ; } } for ( * pn = 0 ; isdigit ( c ); c = getch ()) * pn = 10 * * pn + ( c - '0' ); * pn *= sign ; if ( c != EOF ) ungetch ( c ); return c ; } #define BUFSIZE 100 char buf [ BUFSIZE ]; /* buffer for ungetch */ int bufp = 0 ; /* next free position in buf */ int getch ( void ) /* get a (possibly pushed-back) character */ { return ( bufp > 0 ) ? buf [ -- bufp ] : getchar (); } void ungetch ( int c ) /* push character back on input */ { if ( bufp >= BUFSIZE ) printf ( \"ungetch: too many characters \\n \" ); else buf [ bufp ++ ] = c ; }","title":"Exercise 5-1. As written, getint treats a + or - not followed by a digit as a valid representation of zero. Fix it to push such a character back on the input."}]}